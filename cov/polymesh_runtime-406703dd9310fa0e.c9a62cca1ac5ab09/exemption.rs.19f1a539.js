var data = {lines:[
{"lineNum":"    1","line":"use crate::{"},
{"lineNum":"    2","line":"    asset::{self, AssetTrait},"},
{"lineNum":"    3","line":"    identity, utils,"},
{"lineNum":"    4","line":"};"},
{"lineNum":"    5","line":"use primitives::Key;"},
{"lineNum":"    6","line":""},
{"lineNum":"    7","line":"use codec::Encode;"},
{"lineNum":"    8","line":"use rstd::{convert::TryFrom, prelude::*};"},
{"lineNum":"    9","line":"use srml_support::{decl_event, decl_module, decl_storage, dispatch::Result, ensure};"},
{"lineNum":"   10","line":"use system::ensure_signed;"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"/// The module\'s configuration trait."},
{"lineNum":"   13","line":"pub trait Trait: system::Trait + utils::Trait + identity::Trait {"},
{"lineNum":"   14","line":"    /// The overarching event type."},
{"lineNum":"   15","line":"    type Event: From<Event> + Into<<Self as system::Trait>::Event>;"},
{"lineNum":"   16","line":"    type Asset: asset::AssetTrait<Self::TokenBalance>;"},
{"lineNum":"   17","line":"}"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"// This module\'s storage items."},
{"lineNum":"   20","line":"decl_storage! {","class":"lineCov","hits":"9","order":"6946","possible_hits":"9",},
{"lineNum":"   21","line":"    trait Store for Module<T: Trait> as exemption {"},
{"lineNum":"   22","line":"        // Mapping -> ExemptionList[ticker][TM][DID] = true/false"},
{"lineNum":"   23","line":"        ExemptionList get(exemption_list): map (Vec<u8>, u16, Vec<u8>) => bool;"},
{"lineNum":"   24","line":"    }"},
{"lineNum":"   25","line":"}","class":"linePartCov","hits":"3","order":"6947","possible_hits":"8",},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"// The module\'s dispatchable functions."},
{"lineNum":"   28","line":"decl_module! {"},
{"lineNum":"   29","line":"    /// The module declaration."},
{"lineNum":"   30","line":"    pub struct Module<T: Trait> for enum Call where origin: T::Origin {"},
{"lineNum":"   31","line":"        // Initializing events"},
{"lineNum":"   32","line":"        // this is needed only if you are using events in your module"},
{"lineNum":"   33","line":"        fn deposit_event() = default;"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"        fn modify_exemption_list(origin, did: Vec<u8>, ticker: Vec<u8>, _tm: u16, asset_holder_did: Vec<u8>, exempted: bool) -> Result {"},
{"lineNum":"   36","line":"            let upper_ticker = utils::bytes_to_upper(&ticker);"},
{"lineNum":"   37","line":"            let sender = ensure_signed(origin)?;"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"            // Check that sender is allowed to act on behalf of `did`"},
{"lineNum":"   40","line":"            ensure!(<identity::Module<T>>::is_signing_key(&did, &Key::try_from(sender.encode())?), \"sender must be a signing key for DID\");"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"            ensure!(Self::is_owner(&upper_ticker, &did), \"Sender must be the token owner\");"},
{"lineNum":"   43","line":"            let ticker_asset_holder_did = (ticker.clone(), _tm, asset_holder_did.clone());"},
{"lineNum":"   44","line":"            let is_exempted = Self::exemption_list(&ticker_asset_holder_did);"},
{"lineNum":"   45","line":"            ensure!(is_exempted != exempted, \"No change in the state\");"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"            <ExemptionList>::insert(&ticker_asset_holder_did, exempted);"},
{"lineNum":"   48","line":"            Self::deposit_event(Event::ModifyExemptionList(ticker, _tm, asset_holder_did, exempted));"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"            Ok(())"},
{"lineNum":"   51","line":"        }"},
{"lineNum":"   52","line":"    }"},
{"lineNum":"   53","line":"}"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"decl_event!("},
{"lineNum":"   56","line":"    pub enum Event {"},
{"lineNum":"   57","line":"        ModifyExemptionList(Vec<u8>, u16, Vec<u8>, bool),"},
{"lineNum":"   58","line":"    }"},
{"lineNum":"   59","line":");"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"impl<T: Trait> Module<T> {"},
{"lineNum":"   62","line":"    pub fn is_owner(ticker: &[u8], sender_did: &Vec<u8>) -> bool {"},
{"lineNum":"   63","line":"        let upper_ticker = utils::bytes_to_upper(ticker);"},
{"lineNum":"   64","line":"        T::Asset::is_owner(&upper_ticker, &sender_did)"},
{"lineNum":"   65","line":"    }"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"    pub fn is_exempted(ticker: &[u8], tm: u16, did: Vec<u8>) -> bool {","class":"linePartCov","hits":"2","order":"6943","possible_hits":"4",},
{"lineNum":"   68","line":"        let upper_ticker = utils::bytes_to_upper(ticker);","class":"lineCov","hits":"2","order":"6944","possible_hits":"2",},
{"lineNum":"   69","line":"        Self::exemption_list((upper_ticker, tm, did))","class":"lineCov","hits":"2","order":"6945","possible_hits":"2",},
{"lineNum":"   70","line":"    }","class":"lineCov","hits":"2","order":"6948","possible_hits":"2",},
{"lineNum":"   71","line":"}"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"/// tests for this module"},
{"lineNum":"   74","line":"#[cfg(test)]"},
{"lineNum":"   75","line":"mod tests {"},
{"lineNum":"   76","line":"    // use super::*;"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"    // use substrate_primitives::{Blake2Hasher, H256};"},
{"lineNum":"   79","line":"    // use sr_io::with_externalities;"},
{"lineNum":"   80","line":"    // use sr_primitives::{"},
{"lineNum":"   81","line":"    //     testing::{Digest, DigestItem, Header},"},
{"lineNum":"   82","line":"    //     traits::{BlakeTwo256, IdentityLookup},"},
{"lineNum":"   83","line":"    //     BuildStorage,"},
{"lineNum":"   84","line":"    // };"},
{"lineNum":"   85","line":"    // use srml_support::{assert_ok, impl_outer_origin};"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"    // impl_outer_origin! {"},
{"lineNum":"   88","line":"    //     pub enum Origin for Test {}"},
{"lineNum":"   89","line":"    // }"},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"    // // For testing the module, we construct most of a mock runtime. This means"},
{"lineNum":"   92","line":"    // // first constructing a configuration type (`Test`) which `impl`s each of the"},
{"lineNum":"   93","line":"    // // configuration traits of modules we want to use."},
{"lineNum":"   94","line":"    // #[derive(Clone, Eq, PartialEq)]"},
{"lineNum":"   95","line":"    // pub struct Test;"},
{"lineNum":"   96","line":"    // impl system::Trait for Test {"},
{"lineNum":"   97","line":"    //     type Origin = Origin;"},
{"lineNum":"   98","line":"    //     type Index = u64;"},
{"lineNum":"   99","line":"    //     type BlockNumber = u64;"},
{"lineNum":"  100","line":"    //     type Hash = H256;"},
{"lineNum":"  101","line":"    //     type Hashing = BlakeTwo256;"},
{"lineNum":"  102","line":"    //     type Digest = H256;"},
{"lineNum":"  103","line":"    //     type AccountId = u64;"},
{"lineNum":"  104","line":"    //     type Lookup = IdentityLookup<Self::AccountId>;"},
{"lineNum":"  105","line":"    //     type Header = Header;"},
{"lineNum":"  106","line":"    //     type Event = ();"},
{"lineNum":"  107","line":"    //     type Log = DigestItem;"},
{"lineNum":"  108","line":"    // }"},
{"lineNum":"  109","line":"    // impl Trait for Test {"},
{"lineNum":"  110","line":"    //     type Event = ();"},
{"lineNum":"  111","line":"    // }"},
{"lineNum":"  112","line":"    // type exemption = Module<Test>;"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"    // // This function basically just builds a genesis storage key/value store according to"},
{"lineNum":"  115","line":"    // // our desired mockup."},
{"lineNum":"  116","line":"    // fn new_test_ext() -> sr_io::TestExternalities<Blake2Hasher> {"},
{"lineNum":"  117","line":"    //     system::GenesisConfig::default()"},
{"lineNum":"  118","line":"    //         .build_storage()"},
{"lineNum":"  119","line":"    //         .unwrap()"},
{"lineNum":"  120","line":"    //         .0"},
{"lineNum":"  121","line":"    //         .into()"},
{"lineNum":"  122","line":"    // }"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"    // #[test]"},
{"lineNum":"  125","line":"    // fn it_works_for_default_value() {"},
{"lineNum":"  126","line":"    //     with_externalities(&mut new_test_ext(), || {"},
{"lineNum":"  127","line":"    //         // Just a dummy test for the dummy funtion `do_something`"},
{"lineNum":"  128","line":"    //         // calling the `do_something` function with a value 42"},
{"lineNum":"  129","line":"    //         assert_ok!(exemption::do_something(Origin::signed(1), 42));"},
{"lineNum":"  130","line":"    //         // asserting that the stored value is equal to what we stored"},
{"lineNum":"  131","line":"    //         assert_eq!(exemption::something(), Some(42));"},
{"lineNum":"  132","line":"    //     });"},
{"lineNum":"  133","line":"    // }"},
{"lineNum":"  134","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "polymesh_runtime-406703dd9310fa0e", "date" : "2019-11-06 13:35:33", "instrumented" : 6, "covered" : 6,};
var merged_data = [];
