var data = {lines:[
{"lineNum":"    1","line":"//! # Balances Module"},
{"lineNum":"    2","line":"//!"},
{"lineNum":"    3","line":"//! The Balances module provides functionality for handling accounts and balances."},
{"lineNum":"    4","line":"//!"},
{"lineNum":"    5","line":"//! - [`balances::Trait`](./trait.Trait.html)"},
{"lineNum":"    6","line":"//! - [`Call`](./enum.Call.html)"},
{"lineNum":"    7","line":"//! - [`Module`](./struct.Module.html)"},
{"lineNum":"    8","line":"//!"},
{"lineNum":"    9","line":"//! ## Overview"},
{"lineNum":"   10","line":"//!"},
{"lineNum":"   11","line":"//! The Balances module provides functions for:"},
{"lineNum":"   12","line":"//!"},
{"lineNum":"   13","line":"//! - Getting and setting free balances."},
{"lineNum":"   14","line":"//! - Retrieving total, reserved and unreserved balances."},
{"lineNum":"   15","line":"//! - Repatriating a reserved balance to a beneficiary account that exists."},
{"lineNum":"   16","line":"//! - Transferring a balance between accounts (when not reserved)."},
{"lineNum":"   17","line":"//! - Slashing an account balance."},
{"lineNum":"   18","line":"//! - Account creation and removal."},
{"lineNum":"   19","line":"//! - Managing total issuance."},
{"lineNum":"   20","line":"//! - Setting and managing locks."},
{"lineNum":"   21","line":"//!"},
{"lineNum":"   22","line":"//! ### Terminology"},
{"lineNum":"   23","line":"//!"},
{"lineNum":"   24","line":"//! - **Existential Deposit:** The minimum balance required to create or keep an account open. This prevents"},
{"lineNum":"   25","line":"//! \"dust accounts\" from filling storage."},
{"lineNum":"   26","line":"//! - **Total Issuance:** The total number of units in existence in a system."},
{"lineNum":"   27","line":"//! - **Reaping an account:** The act of removing an account by resetting its nonce. Happens after its balance is set"},
{"lineNum":"   28","line":"//! to zero."},
{"lineNum":"   29","line":"//! - **Free Balance:** The portion of a balance that is not reserved. The free balance is the only balance that matters"},
{"lineNum":"   30","line":"//! for most operations. When this balance falls below the existential deposit, most functionality of the account is"},
{"lineNum":"   31","line":"//! removed. When both it and the reserved balance are deleted, then the account is said to be dead."},
{"lineNum":"   32","line":"//! - **Reserved Balance:** Reserved balance still belongs to the account holder, but is suspended. Reserved balance"},
{"lineNum":"   33","line":"//! can still be slashed, but only after all the free balance has been slashed. If the reserved balance falls below the"},
{"lineNum":"   34","line":"//! existential deposit then it and any related functionality will be deleted. When both it and the free balance are"},
{"lineNum":"   35","line":"//! deleted, then the account is said to be dead."},
{"lineNum":"   36","line":"//! - **Imbalance:** A condition when some funds were credited or debited without equal and opposite accounting"},
{"lineNum":"   37","line":"//! (i.e. a difference between total issuance and account balances). Functions that result in an imbalance will"},
{"lineNum":"   38","line":"//! return an object of the `Imbalance` trait that can be managed within your runtime logic. (If an imbalance is"},
{"lineNum":"   39","line":"//! simply dropped, it should automatically maintain any book-keeping such as total issuance.)"},
{"lineNum":"   40","line":"//! - **Lock:** A freeze on a specified amount of an account\'s free balance until a specified block number. Multiple"},
{"lineNum":"   41","line":"//! locks always operate over the same funds, so they \"overlay\" rather than \"stack\"."},
{"lineNum":"   42","line":"//! - **Vesting:** Similar to a lock, this is another, but independent, liquidity restriction that reduces linearly"},
{"lineNum":"   43","line":"//! over time."},
{"lineNum":"   44","line":"//!"},
{"lineNum":"   45","line":"//! ### Implementations"},
{"lineNum":"   46","line":"//!"},
{"lineNum":"   47","line":"//! The Balances module provides implementations for the following traits. If these traits provide the functionality"},
{"lineNum":"   48","line":"//! that you need, then you can avoid coupling with the Balances module."},
{"lineNum":"   49","line":"//!"},
{"lineNum":"   50","line":"//! - [`Currency`](../srml_support/traits/trait.Currency.html): Functions for dealing with a"},
{"lineNum":"   51","line":"//! fungible assets system."},
{"lineNum":"   52","line":"//! - [`ReservableCurrency`](../srml_support/traits/trait.ReservableCurrency.html):"},
{"lineNum":"   53","line":"//! Functions for dealing with assets that can be reserved from an account."},
{"lineNum":"   54","line":"//! - [`LockableCurrency`](../srml_support/traits/trait.LockableCurrency.html): Functions for"},
{"lineNum":"   55","line":"//! dealing with accounts that allow liquidity restrictions."},
{"lineNum":"   56","line":"//! - [`Imbalance`](../srml_support/traits/trait.Imbalance.html): Functions for handling"},
{"lineNum":"   57","line":"//! imbalances between total issuance in the system and account balances. Must be used when a function"},
{"lineNum":"   58","line":"//! creates new funds (e.g. a reward) or destroys some funds (e.g. a system fee)."},
{"lineNum":"   59","line":"//! - [`IsDeadAccount`](../srml_system/trait.IsDeadAccount.html): Determiner to say whether a"},
{"lineNum":"   60","line":"//! given account is unused."},
{"lineNum":"   61","line":"//!"},
{"lineNum":"   62","line":"//! ## Interface"},
{"lineNum":"   63","line":"//!"},
{"lineNum":"   64","line":"//! ### Dispatchable Functions"},
{"lineNum":"   65","line":"//!"},
{"lineNum":"   66","line":"//! - `transfer` - Transfer some liquid free balance to another account."},
{"lineNum":"   67","line":"//! - `set_balance` - Set the balances of a given account. The origin of this call must be root."},
{"lineNum":"   68","line":"//!"},
{"lineNum":"   69","line":"//! ### Public Functions"},
{"lineNum":"   70","line":"//!"},
{"lineNum":"   71","line":"//! - `vesting_balance` - Get the amount that is currently being vested and cannot be transferred out of this account."},
{"lineNum":"   72","line":"//!"},
{"lineNum":"   73","line":"//! ### Signed Extensions"},
{"lineNum":"   74","line":"//!"},
{"lineNum":"   75","line":"//! The balances module defines the following extensions:"},
{"lineNum":"   76","line":"//!"},
{"lineNum":"   77","line":"//!   - [`TakeFees`]: Consumes fees proportional to the length and weight of the transaction."},
{"lineNum":"   78","line":"//!     Additionally, it can contain a single encoded payload as a `tip`. The inclusion priority"},
{"lineNum":"   79","line":"//!     is increased proportional to the tip."},
{"lineNum":"   80","line":"//!"},
{"lineNum":"   81","line":"//! Lookup the runtime aggregator file (e.g. `node/runtime`) to see the full list of signed"},
{"lineNum":"   82","line":"//! extensions included in a chain."},
{"lineNum":"   83","line":"//!"},
{"lineNum":"   84","line":"//! ## Usage"},
{"lineNum":"   85","line":"//!"},
{"lineNum":"   86","line":"//! The following examples show how to use the Balances module in your custom module."},
{"lineNum":"   87","line":"//!"},
{"lineNum":"   88","line":"//! ### Examples from the SRML"},
{"lineNum":"   89","line":"//!"},
{"lineNum":"   90","line":"//! The Contract module uses the `Currency` trait to handle gas payment, and its types inherit from `Currency`:"},
{"lineNum":"   91","line":"//!"},
{"lineNum":"   92","line":"//! ```"},
{"lineNum":"   93","line":"//! use srml_support::traits::Currency;"},
{"lineNum":"   94","line":"//! # pub trait Trait: system::Trait {"},
{"lineNum":"   95","line":"//! # \ttype Currency: Currency<Self::AccountId>;"},
{"lineNum":"   96","line":"//! # }"},
{"lineNum":"   97","line":"//!"},
{"lineNum":"   98","line":"//! pub type BalanceOf<T> = <<T as Trait>::Currency as Currency<<T as system::Trait>::AccountId>>::Balance;"},
{"lineNum":"   99","line":"//! pub type NegativeImbalanceOf<T> = <<T as Trait>::Currency as Currency<<T as system::Trait>::AccountId>>::NegativeImbalance;"},
{"lineNum":"  100","line":"//!"},
{"lineNum":"  101","line":"//! # fn main() {}"},
{"lineNum":"  102","line":"//! ```"},
{"lineNum":"  103","line":"//!"},
{"lineNum":"  104","line":"//! The Staking module uses the `LockableCurrency` trait to lock a stash account\'s funds:"},
{"lineNum":"  105","line":"//!"},
{"lineNum":"  106","line":"//! ```"},
{"lineNum":"  107","line":"//! use srml_support::traits::{WithdrawReasons, LockableCurrency};"},
{"lineNum":"  108","line":"//! use sr_primitives::traits::Bounded;"},
{"lineNum":"  109","line":"//! pub trait Trait: system::Trait {"},
{"lineNum":"  110","line":"//! \ttype Currency: LockableCurrency<Self::AccountId, Moment=Self::BlockNumber>;"},
{"lineNum":"  111","line":"//! }"},
{"lineNum":"  112","line":"//! # struct StakingLedger<T: Trait> {"},
{"lineNum":"  113","line":"//! # \tstash: <T as system::Trait>::AccountId,"},
{"lineNum":"  114","line":"//! # \ttotal: <<T as Trait>::Currency as srml_support::traits::Currency<<T as system::Trait>::AccountId>>::Balance,"},
{"lineNum":"  115","line":"//! # \tphantom: std::marker::PhantomData<T>,"},
{"lineNum":"  116","line":"//! # }"},
{"lineNum":"  117","line":"//! # const STAKING_ID: [u8; 8] = *b\"staking \";"},
{"lineNum":"  118","line":"//!"},
{"lineNum":"  119","line":"//! fn update_ledger<T: Trait>("},
{"lineNum":"  120","line":"//! \tcontroller: &T::AccountId,"},
{"lineNum":"  121","line":"//! \tledger: &StakingLedger<T>"},
{"lineNum":"  122","line":"//! ) {"},
{"lineNum":"  123","line":"//! \tT::Currency::set_lock("},
{"lineNum":"  124","line":"//! \t\tSTAKING_ID,"},
{"lineNum":"  125","line":"//! \t\t&ledger.stash,"},
{"lineNum":"  126","line":"//! \t\tledger.total,"},
{"lineNum":"  127","line":"//! \t\tT::BlockNumber::max_value(),"},
{"lineNum":"  128","line":"//! \t\tWithdrawReasons::all()"},
{"lineNum":"  129","line":"//! \t);"},
{"lineNum":"  130","line":"//! \t// <Ledger<T>>::insert(controller, ledger); // Commented out as we don\'t have access to Staking\'s storage here."},
{"lineNum":"  131","line":"//! }"},
{"lineNum":"  132","line":"//! # fn main() {}"},
{"lineNum":"  133","line":"//! ```"},
{"lineNum":"  134","line":"//!"},
{"lineNum":"  135","line":"//! ## Genesis config"},
{"lineNum":"  136","line":"//!"},
{"lineNum":"  137","line":"//! The Balances module depends on the [`GenesisConfig`](./struct.GenesisConfig.html)."},
{"lineNum":"  138","line":"//!"},
{"lineNum":"  139","line":"//! ## Assumptions"},
{"lineNum":"  140","line":"//!"},
{"lineNum":"  141","line":"//! * Total issued balanced of all accounts should be less than `Trait::Balance::max_value()`."},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"#![cfg_attr(not(feature = \"std\"), no_std)]"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"use codec::{Codec, Decode, Encode};"},
{"lineNum":"  146","line":"use rstd::{cmp, convert::TryFrom, mem, prelude::*, result};"},
{"lineNum":"  147","line":"use sr_primitives::traits::{"},
{"lineNum":"  148","line":"    Bounded, CheckedAdd, CheckedSub, Convert, MaybeSerializeDebug, Member, SaturatedConversion,"},
{"lineNum":"  149","line":"    Saturating, SignedExtension, SimpleArithmetic, StaticLookup, Zero,"},
{"lineNum":"  150","line":"};"},
{"lineNum":"  151","line":"use sr_primitives::transaction_validity::{"},
{"lineNum":"  152","line":"    InvalidTransaction, TransactionPriority, TransactionValidity, TransactionValidityError,"},
{"lineNum":"  153","line":"    ValidTransaction,"},
{"lineNum":"  154","line":"};"},
{"lineNum":"  155","line":"use sr_primitives::weights::{DispatchInfo, SimpleDispatchInfo, Weight};"},
{"lineNum":"  156","line":"use srml_support::dispatch::Result;"},
{"lineNum":"  157","line":"use srml_support::traits::{"},
{"lineNum":"  158","line":"    Currency, ExistenceRequirement, Get, Imbalance, LockIdentifier, LockableCurrency,"},
{"lineNum":"  159","line":"    OnFreeBalanceZero, OnUnbalanced, ReservableCurrency, SignedImbalance, UpdateBalanceOutcome,"},
{"lineNum":"  160","line":"    WithdrawReason, WithdrawReasons,"},
{"lineNum":"  161","line":"};"},
{"lineNum":"  162","line":"use srml_support::{decl_event, decl_module, decl_storage, Parameter, StorageValue};"},
{"lineNum":"  163","line":"use system::{ensure_root, ensure_signed, IsDeadAccount, OnNewAccount};"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"use crate::identity::IdentityTrait;"},
{"lineNum":"  166","line":"use primitives::Key;"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"pub use self::imbalances::{NegativeImbalance, PositiveImbalance};"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"pub trait Subtrait<I: Instance = DefaultInstance>: system::Trait {"},
{"lineNum":"  171","line":"    /// The balance of an account."},
{"lineNum":"  172","line":"    type Balance: Parameter"},
{"lineNum":"  173","line":"        + Member"},
{"lineNum":"  174","line":"        + SimpleArithmetic"},
{"lineNum":"  175","line":"        + Codec"},
{"lineNum":"  176","line":"        + Default"},
{"lineNum":"  177","line":"        + Copy"},
{"lineNum":"  178","line":"        + MaybeSerializeDebug"},
{"lineNum":"  179","line":"        + From<Self::BlockNumber>;"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"    /// A function that is invoked when the free-balance has fallen below the existential deposit and"},
{"lineNum":"  182","line":"    /// has been reduced to zero."},
{"lineNum":"  183","line":"    ///"},
{"lineNum":"  184","line":"    /// Gives a chance to clean up resources associated with the given account."},
{"lineNum":"  185","line":"    type OnFreeBalanceZero: OnFreeBalanceZero<Self::AccountId>;"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"    /// Handler for when a new account is created."},
{"lineNum":"  188","line":"    type OnNewAccount: OnNewAccount<Self::AccountId>;"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"    /// The minimum amount required to keep an account open."},
{"lineNum":"  191","line":"    type ExistentialDeposit: Get<Self::Balance>;"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"    /// The fee required to make a transfer."},
{"lineNum":"  194","line":"    type TransferFee: Get<Self::Balance>;"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"    /// The fee required to create an account."},
{"lineNum":"  197","line":"    type CreationFee: Get<Self::Balance>;"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"    /// The fee to be paid for making a transaction; the base."},
{"lineNum":"  200","line":"    type TransactionBaseFee: Get<Self::Balance>;"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"    /// The fee to be paid for making a transaction; the per-byte portion."},
{"lineNum":"  203","line":"    type TransactionByteFee: Get<Self::Balance>;"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"    /// Convert a weight value into a deductible fee based on the currency type."},
{"lineNum":"  206","line":"    type WeightToFee: Convert<Weight, Self::Balance>;"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"    type Identity: IdentityTrait<Self::Balance>;"},
{"lineNum":"  209","line":"}"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"pub trait Trait<I: Instance = DefaultInstance>: system::Trait {"},
{"lineNum":"  212","line":"    /// The balance of an account."},
{"lineNum":"  213","line":"    type Balance: Parameter"},
{"lineNum":"  214","line":"        + Member"},
{"lineNum":"  215","line":"        + SimpleArithmetic"},
{"lineNum":"  216","line":"        + Codec"},
{"lineNum":"  217","line":"        + Default"},
{"lineNum":"  218","line":"        + Copy"},
{"lineNum":"  219","line":"        + MaybeSerializeDebug"},
{"lineNum":"  220","line":"        + From<Self::BlockNumber>;"},
{"lineNum":"  221","line":""},
{"lineNum":"  222","line":"    /// A function that is invoked when the free-balance has fallen below the existential deposit and"},
{"lineNum":"  223","line":"    /// has been reduced to zero."},
{"lineNum":"  224","line":"    ///"},
{"lineNum":"  225","line":"    /// Gives a chance to clean up resources associated with the given account."},
{"lineNum":"  226","line":"    type OnFreeBalanceZero: OnFreeBalanceZero<Self::AccountId>;"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"    /// Handler for when a new account is created."},
{"lineNum":"  229","line":"    type OnNewAccount: OnNewAccount<Self::AccountId>;"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"    /// Handler for the unbalanced reduction when taking transaction fees."},
{"lineNum":"  232","line":"    type TransactionPayment: OnUnbalanced<NegativeImbalance<Self, I>>;"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"    /// Handler for the unbalanced reduction when taking fees associated with balance"},
{"lineNum":"  235","line":"    /// transfer (which may also include account creation)."},
{"lineNum":"  236","line":"    type TransferPayment: OnUnbalanced<NegativeImbalance<Self, I>>;"},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"    /// Handler for the unbalanced reduction when removing a dust account."},
{"lineNum":"  239","line":"    type DustRemoval: OnUnbalanced<NegativeImbalance<Self, I>>;"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"    /// The overarching event type."},
{"lineNum":"  242","line":"    type Event: From<Event<Self, I>> + Into<<Self as system::Trait>::Event>;"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"    /// The minimum amount required to keep an account open."},
{"lineNum":"  245","line":"    type ExistentialDeposit: Get<Self::Balance>;"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"    /// The fee required to make a transfer."},
{"lineNum":"  248","line":"    type TransferFee: Get<Self::Balance>;"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"    /// The fee required to create an account."},
{"lineNum":"  251","line":"    type CreationFee: Get<Self::Balance>;"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"    /// The fee to be paid for making a transaction; the base."},
{"lineNum":"  254","line":"    type TransactionBaseFee: Get<Self::Balance>;"},
{"lineNum":"  255","line":""},
{"lineNum":"  256","line":"    /// The fee to be paid for making a transaction; the per-byte portion."},
{"lineNum":"  257","line":"    type TransactionByteFee: Get<Self::Balance>;"},
{"lineNum":"  258","line":""},
{"lineNum":"  259","line":"    /// Convert a weight value into a deductible fee based on the currency type."},
{"lineNum":"  260","line":"    type WeightToFee: Convert<Weight, Self::Balance>;"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"    type Identity: IdentityTrait<Self::Balance>;"},
{"lineNum":"  263","line":"}"},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"impl<T: Trait<I>, I: Instance> Subtrait<I> for T {"},
{"lineNum":"  266","line":"    type Balance = T::Balance;"},
{"lineNum":"  267","line":"    type OnFreeBalanceZero = T::OnFreeBalanceZero;"},
{"lineNum":"  268","line":"    type OnNewAccount = T::OnNewAccount;"},
{"lineNum":"  269","line":"    type ExistentialDeposit = T::ExistentialDeposit;"},
{"lineNum":"  270","line":"    type TransferFee = T::TransferFee;"},
{"lineNum":"  271","line":"    type CreationFee = T::CreationFee;"},
{"lineNum":"  272","line":"    type TransactionBaseFee = T::TransactionBaseFee;"},
{"lineNum":"  273","line":"    type TransactionByteFee = T::TransactionByteFee;"},
{"lineNum":"  274","line":"    type WeightToFee = T::WeightToFee;"},
{"lineNum":"  275","line":"    type Identity = T::Identity;"},
{"lineNum":"  276","line":"}"},
{"lineNum":"  277","line":""},
{"lineNum":"  278","line":"decl_event!("},
{"lineNum":"  279","line":"\tpub enum Event<T, I: Instance = DefaultInstance> where"},
{"lineNum":"  280","line":"\t\t<T as system::Trait>::AccountId,"},
{"lineNum":"  281","line":"\t\t<T as Trait<I>>::Balance"},
{"lineNum":"  282","line":"\t{"},
{"lineNum":"  283","line":"\t\t/// A new account was created."},
{"lineNum":"  284","line":"\t\tNewAccount(AccountId, Balance),"},
{"lineNum":"  285","line":"\t\t/// An account was reaped."},
{"lineNum":"  286","line":"\t\tReapedAccount(AccountId),"},
{"lineNum":"  287","line":"\t\t/// Transfer succeeded (from, to, value, fees)."},
{"lineNum":"  288","line":"\t\tTransfer(AccountId, AccountId, Balance, Balance),"},
{"lineNum":"  289","line":"\t}"},
{"lineNum":"  290","line":");"},
{"lineNum":"  291","line":""},
{"lineNum":"  292","line":"/// Struct to encode the vesting schedule of an individual account."},
{"lineNum":"  293","line":"#[derive(Encode, Decode, Copy, Clone, PartialEq, Eq)]","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  294","line":"#[cfg_attr(feature = \"std\", derive(Debug))]"},
{"lineNum":"  295","line":"pub struct VestingSchedule<Balance, BlockNumber> {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  296","line":"    /// Locked amount at genesis.","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  297","line":"    pub locked: Balance,"},
{"lineNum":"  298","line":"    /// Amount that gets unlocked every block after `starting_block`.","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  299","line":"    pub per_block: Balance,"},
{"lineNum":"  300","line":"    /// Starting block for unlocking(vesting).","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  301","line":"    pub starting_block: BlockNumber,"},
{"lineNum":"  302","line":"}","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"impl<Balance: SimpleArithmetic + Copy, BlockNumber: SimpleArithmetic + Copy>"},
{"lineNum":"  305","line":"    VestingSchedule<Balance, BlockNumber>"},
{"lineNum":"  306","line":"{"},
{"lineNum":"  307","line":"    /// Amount locked at block `n`."},
{"lineNum":"  308","line":"    pub fn locked_at(&self, n: BlockNumber) -> Balance","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  309","line":"    where"},
{"lineNum":"  310","line":"        Balance: From<BlockNumber>,"},
{"lineNum":"  311","line":"    {"},
{"lineNum":"  312","line":"        // Number of blocks that count toward vesting"},
{"lineNum":"  313","line":"        // Saturating to 0 when n < starting_block"},
{"lineNum":"  314","line":"        let vested_block_count = n.saturating_sub(self.starting_block);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  315","line":"        // Return amount that is still locked in vesting"},
{"lineNum":"  316","line":"        if let Some(x) = Balance::from(vested_block_count).checked_mul(&self.per_block) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  317","line":"            self.locked.max(x) - x","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  318","line":"        } else {"},
{"lineNum":"  319","line":"            Zero::zero()","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  320","line":"        }"},
{"lineNum":"  321","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  322","line":"}"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"#[derive(Encode, Decode, Clone, PartialEq, Eq)]","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  325","line":"#[cfg_attr(feature = \"std\", derive(Debug))]"},
{"lineNum":"  326","line":"pub struct BalanceLock<Balance, BlockNumber> {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  327","line":"    pub id: LockIdentifier,","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  328","line":"    pub amount: Balance,","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  329","line":"    pub until: BlockNumber,","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  330","line":"    pub reasons: WithdrawReasons,","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  331","line":"}","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  332","line":""},
{"lineNum":"  333","line":"decl_storage! {","class":"linePartCov","hits":"63","order":"5268","possible_hits":"105",},
{"lineNum":"  334","line":"    trait Store for Module<T: Trait<I>, I: Instance=DefaultInstance> as Balances {"},
{"lineNum":"  335","line":"        /// The total units issued in the system."},
{"lineNum":"  336","line":"        pub TotalIssuance get(total_issuance) build(|config: &GenesisConfig<T, I>| {"},
{"lineNum":"  337","line":"            config.balances.iter().fold(Zero::zero(), |acc: T::Balance, &(_, n)| acc + n)"},
{"lineNum":"  338","line":"        }): T::Balance;"},
{"lineNum":"  339","line":""},
{"lineNum":"  340","line":"        /// Information regarding the vesting of a given account."},
{"lineNum":"  341","line":"        pub Vesting get(vesting) build(|config: &GenesisConfig<T, I>| {"},
{"lineNum":"  342","line":"            // Generate initial vesting configuration"},
{"lineNum":"  343","line":"            // * who - Account which we are generating vesting configuration for"},
{"lineNum":"  344","line":"            // * begin - Block when the account will start to vest"},
{"lineNum":"  345","line":"            // * length - Number of blocks from `begin` until fully vested"},
{"lineNum":"  346","line":"            // * liquid - Number of units which can be spent before vesting begins"},
{"lineNum":"  347","line":"            config.vesting.iter().filter_map(|&(ref who, begin, length, liquid)| {"},
{"lineNum":"  348","line":"                let length = <T::Balance as From<T::BlockNumber>>::from(length);"},
{"lineNum":"  349","line":""},
{"lineNum":"  350","line":"                config.balances.iter()"},
{"lineNum":"  351","line":"                    .find(|&&(ref w, _)| w == who)"},
{"lineNum":"  352","line":"                    .map(|&(_, balance)| {"},
{"lineNum":"  353","line":"                        // Total genesis `balance` minus `liquid` equals funds locked for vesting"},
{"lineNum":"  354","line":"                        let locked = balance.saturating_sub(liquid);"},
{"lineNum":"  355","line":"                        // Number of units unlocked per block after `begin`"},
{"lineNum":"  356","line":"                        let per_block = locked / length.max(sr_primitives::traits::One::one());"},
{"lineNum":"  357","line":""},
{"lineNum":"  358","line":"                        (who.clone(), VestingSchedule {"},
{"lineNum":"  359","line":"                            locked: locked,"},
{"lineNum":"  360","line":"                            per_block: per_block,"},
{"lineNum":"  361","line":"                            starting_block: begin"},
{"lineNum":"  362","line":"                        })"},
{"lineNum":"  363","line":"                    })"},
{"lineNum":"  364","line":"            }).collect::<Vec<_>>()"},
{"lineNum":"  365","line":"        }): map T::AccountId => Option<VestingSchedule<T::Balance, T::BlockNumber>>;"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"        /// The \'free\' balance of a given account."},
{"lineNum":"  368","line":"        ///"},
{"lineNum":"  369","line":"        /// This is the only balance that matters in terms of most operations on tokens. It"},
{"lineNum":"  370","line":"        /// alone is used to determine the balance when in the contract execution environment. When this"},
{"lineNum":"  371","line":"        /// balance falls below the value of `ExistentialDeposit`, then the \'current account\' is"},
{"lineNum":"  372","line":"        /// deleted: specifically `FreeBalance`. Further, the `OnFreeBalanceZero` callback"},
{"lineNum":"  373","line":"        /// is invoked, giving a chance to external modules to clean up data associated with"},
{"lineNum":"  374","line":"        /// the deleted account."},
{"lineNum":"  375","line":"        ///"},
{"lineNum":"  376","line":"        /// `system::AccountNonce` is also deleted if `ReservedBalance` is also zero (it also gets"},
{"lineNum":"  377","line":"        /// collapsed to zero if it ever becomes less than `ExistentialDeposit`."},
{"lineNum":"  378","line":"        pub FreeBalance get(free_balance)"},
{"lineNum":"  379","line":"            build(|config: &GenesisConfig<T, I>| config.balances.clone()):"},
{"lineNum":"  380","line":"            map T::AccountId => T::Balance;"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"        /// The amount of the balance of a given account that is externally reserved; this can still get"},
{"lineNum":"  383","line":"        /// slashed, but gets slashed last of all."},
{"lineNum":"  384","line":"        ///"},
{"lineNum":"  385","line":"        /// This balance is a \'reserve\' balance that other subsystems use in order to set aside tokens"},
{"lineNum":"  386","line":"        /// that are still \'owned\' by the account holder, but which are suspendable."},
{"lineNum":"  387","line":"        ///"},
{"lineNum":"  388","line":"        /// When this balance falls below the value of `ExistentialDeposit`, then this \'reserve account\'"},
{"lineNum":"  389","line":"        /// is deleted: specifically, `ReservedBalance`."},
{"lineNum":"  390","line":"        ///"},
{"lineNum":"  391","line":"        /// `system::AccountNonce` is also deleted if `FreeBalance` is also zero (it also gets"},
{"lineNum":"  392","line":"        /// collapsed to zero if it ever becomes less than `ExistentialDeposit`.)"},
{"lineNum":"  393","line":"        pub ReservedBalance get(reserved_balance): map T::AccountId => T::Balance;"},
{"lineNum":"  394","line":""},
{"lineNum":"  395","line":"        /// Any liquidity locks on some account balances."},
{"lineNum":"  396","line":"        pub Locks get(locks): map T::AccountId => Vec<BalanceLock<T::Balance, T::BlockNumber>>;"},
{"lineNum":"  397","line":"    }"},
{"lineNum":"  398","line":"    add_extra_genesis {"},
{"lineNum":"  399","line":"        config(balances): Vec<(T::AccountId, T::Balance)>;"},
{"lineNum":"  400","line":"        config(vesting): Vec<(T::AccountId, T::BlockNumber, T::BlockNumber, T::Balance)>;"},
{"lineNum":"  401","line":"        // ^^ begin, length, amount liquid at genesis"},
{"lineNum":"  402","line":"    }"},
{"lineNum":"  403","line":"}","class":"linePartCov","hits":"30","order":"5269","possible_hits":"108",},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":"decl_module! {"},
{"lineNum":"  406","line":"    pub struct Module<T: Trait<I>, I: Instance = DefaultInstance> for enum Call where origin: T::Origin {"},
{"lineNum":"  407","line":"        /// The minimum amount required to keep an account open."},
{"lineNum":"  408","line":"        const ExistentialDeposit: T::Balance = T::ExistentialDeposit::get();"},
{"lineNum":"  409","line":""},
{"lineNum":"  410","line":"        /// The fee required to make a transfer."},
{"lineNum":"  411","line":"        const TransferFee: T::Balance = T::TransferFee::get();"},
{"lineNum":"  412","line":""},
{"lineNum":"  413","line":"        /// The fee required to create an account."},
{"lineNum":"  414","line":"        const CreationFee: T::Balance = T::CreationFee::get();"},
{"lineNum":"  415","line":""},
{"lineNum":"  416","line":"        /// The fee to be paid for making a transaction; the base."},
{"lineNum":"  417","line":"        const TransactionBaseFee: T::Balance = T::TransactionBaseFee::get();"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"        /// The fee to be paid for making a transaction; the per-byte portion."},
{"lineNum":"  420","line":"        const TransactionByteFee: T::Balance = T::TransactionByteFee::get();"},
{"lineNum":"  421","line":""},
{"lineNum":"  422","line":"        fn deposit_event() = default;"},
{"lineNum":"  423","line":""},
{"lineNum":"  424","line":"        /// Transfer some liquid free balance to another account."},
{"lineNum":"  425","line":"        ///"},
{"lineNum":"  426","line":"        /// `transfer` will set the `FreeBalance` of the sender and receiver."},
{"lineNum":"  427","line":"        /// It will decrease the total issuance of the system by the `TransferFee`."},
{"lineNum":"  428","line":"        /// If the sender\'s account is below the existential deposit as a result"},
{"lineNum":"  429","line":"        /// of the transfer, the account will be reaped."},
{"lineNum":"  430","line":"        ///"},
{"lineNum":"  431","line":"        /// The dispatch origin for this call must be `Signed` by the transactor."},
{"lineNum":"  432","line":"        ///"},
{"lineNum":"  433","line":"        /// # <weight>"},
{"lineNum":"  434","line":"        /// - Dependent on arguments but not critical, given proper implementations for"},
{"lineNum":"  435","line":"        ///   input config types. See related functions below."},
{"lineNum":"  436","line":"        /// - It contains a limited number of reads and writes internally and no complex computation."},
{"lineNum":"  437","line":"        ///"},
{"lineNum":"  438","line":"        /// Related functions:"},
{"lineNum":"  439","line":"        ///"},
{"lineNum":"  440","line":"        ///   - `ensure_can_withdraw` is always called internally but has a bounded complexity."},
{"lineNum":"  441","line":"        ///   - Transferring balances to accounts that did not exist before will cause"},
{"lineNum":"  442","line":"        ///      `T::OnNewAccount::on_new_account` to be called."},
{"lineNum":"  443","line":"        ///   - Removing enough funds from an account will trigger"},
{"lineNum":"  444","line":"        ///     `T::DustRemoval::on_unbalanced` and `T::OnFreeBalanceZero::on_free_balance_zero`."},
{"lineNum":"  445","line":"        ///"},
{"lineNum":"  446","line":"        /// # </weight>"},
{"lineNum":"  447","line":"        #[weight = SimpleDispatchInfo::FixedNormal(1_000_000)]"},
{"lineNum":"  448","line":"        pub fn transfer("},
{"lineNum":"  449","line":"            origin,"},
{"lineNum":"  450","line":"            dest: <T::Lookup as StaticLookup>::Source,"},
{"lineNum":"  451","line":"            #[compact] value: T::Balance"},
{"lineNum":"  452","line":"        ) {"},
{"lineNum":"  453","line":"            let transactor = ensure_signed(origin)?;"},
{"lineNum":"  454","line":"            let dest = T::Lookup::lookup(dest)?;"},
{"lineNum":"  455","line":"            <Self as Currency<_>>::transfer(&transactor, &dest, value)?;"},
{"lineNum":"  456","line":"        }"},
{"lineNum":"  457","line":""},
{"lineNum":"  458","line":"        /// Set the balances of a given account."},
{"lineNum":"  459","line":"        ///"},
{"lineNum":"  460","line":"        /// This will alter `FreeBalance` and `ReservedBalance` in storage. it will"},
{"lineNum":"  461","line":"        /// also decrease the total issuance of the system (`TotalIssuance`)."},
{"lineNum":"  462","line":"        /// If the new free or reserved balance is below the existential deposit,"},
{"lineNum":"  463","line":"        /// it will reset the account nonce (`system::AccountNonce`)."},
{"lineNum":"  464","line":"        ///"},
{"lineNum":"  465","line":"        /// The dispatch origin for this call is `root`."},
{"lineNum":"  466","line":"        ///"},
{"lineNum":"  467","line":"        /// # <weight>"},
{"lineNum":"  468","line":"        /// - Independent of the arguments."},
{"lineNum":"  469","line":"        /// - Contains a limited number of reads and writes."},
{"lineNum":"  470","line":"        /// # </weight>"},
{"lineNum":"  471","line":"        #[weight = SimpleDispatchInfo::FixedOperational(50_000)]"},
{"lineNum":"  472","line":"        fn set_balance("},
{"lineNum":"  473","line":"            origin,"},
{"lineNum":"  474","line":"            who: <T::Lookup as StaticLookup>::Source,"},
{"lineNum":"  475","line":"            #[compact] new_free: T::Balance,"},
{"lineNum":"  476","line":"            #[compact] new_reserved: T::Balance"},
{"lineNum":"  477","line":"        ) {"},
{"lineNum":"  478","line":"            ensure_root(origin)?;"},
{"lineNum":"  479","line":"            let who = T::Lookup::lookup(who)?;"},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"            let current_free = <FreeBalance<T, I>>::get(&who);"},
{"lineNum":"  482","line":"            if new_free > current_free {"},
{"lineNum":"  483","line":"                mem::drop(PositiveImbalance::<T, I>::new(new_free - current_free));"},
{"lineNum":"  484","line":"            } else if new_free < current_free {"},
{"lineNum":"  485","line":"                mem::drop(NegativeImbalance::<T, I>::new(current_free - new_free));"},
{"lineNum":"  486","line":"            }"},
{"lineNum":"  487","line":"            Self::set_free_balance(&who, new_free);"},
{"lineNum":"  488","line":""},
{"lineNum":"  489","line":"            let current_reserved = <ReservedBalance<T, I>>::get(&who);"},
{"lineNum":"  490","line":"            if new_reserved > current_reserved {"},
{"lineNum":"  491","line":"                mem::drop(PositiveImbalance::<T, I>::new(new_reserved - current_reserved));"},
{"lineNum":"  492","line":"            } else if new_reserved < current_reserved {"},
{"lineNum":"  493","line":"                mem::drop(NegativeImbalance::<T, I>::new(current_reserved - new_reserved));"},
{"lineNum":"  494","line":"            }"},
{"lineNum":"  495","line":"            Self::set_reserved_balance(&who, new_reserved);"},
{"lineNum":"  496","line":"        }"},
{"lineNum":"  497","line":""},
{"lineNum":"  498","line":"        /// Exactly as `transfer`, except the origin must be root and the source account may be"},
{"lineNum":"  499","line":"        /// specified."},
{"lineNum":"  500","line":"        #[weight = SimpleDispatchInfo::FixedNormal(1_000_000)]"},
{"lineNum":"  501","line":"        pub fn force_transfer("},
{"lineNum":"  502","line":"            origin,"},
{"lineNum":"  503","line":"            source: <T::Lookup as StaticLookup>::Source,"},
{"lineNum":"  504","line":"            dest: <T::Lookup as StaticLookup>::Source,"},
{"lineNum":"  505","line":"            #[compact] value: T::Balance"},
{"lineNum":"  506","line":"        ) {"},
{"lineNum":"  507","line":"            ensure_root(origin)?;"},
{"lineNum":"  508","line":"            let source = T::Lookup::lookup(source)?;"},
{"lineNum":"  509","line":"            let dest = T::Lookup::lookup(dest)?;"},
{"lineNum":"  510","line":"            <Self as Currency<_>>::transfer(&source, &dest, value)?;"},
{"lineNum":"  511","line":"        }"},
{"lineNum":"  512","line":"    }"},
{"lineNum":"  513","line":"}"},
{"lineNum":"  514","line":""},
{"lineNum":"  515","line":"impl<T: Trait<I>, I: Instance> Module<T, I> {"},
{"lineNum":"  516","line":"    // PUBLIC IMMUTABLES"},
{"lineNum":"  517","line":""},
{"lineNum":"  518","line":"    /// Get the amount that is currently being vested and cannot be transferred out of this account."},
{"lineNum":"  519","line":"    pub fn vesting_balance(who: &T::AccountId) -> T::Balance {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  520","line":"        if let Some(v) = Self::vesting(who) {","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  521","line":"            Self::free_balance(who).min(v.locked_at(<system::Module<T>>::block_number()))","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  522","line":"        } else {"},
{"lineNum":"  523","line":"            Zero::zero()","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  524","line":"        }"},
{"lineNum":"  525","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"    // PRIVATE MUTABLES"},
{"lineNum":"  528","line":""},
{"lineNum":"  529","line":"    /// Set the reserved balance of an account to some new value. Will enforce `ExistentialDeposit`"},
{"lineNum":"  530","line":"    /// law, annulling the account as needed."},
{"lineNum":"  531","line":"    ///"},
{"lineNum":"  532","line":"    /// Doesn\'t do any preparatory work for creating a new account, so should only be used when it"},
{"lineNum":"  533","line":"    /// is known that the account already exists."},
{"lineNum":"  534","line":"    ///"},
{"lineNum":"  535","line":"    /// NOTE: LOW-LEVEL: This will not attempt to maintain total issuance. It is expected that"},
{"lineNum":"  536","line":"    /// the caller will do this."},
{"lineNum":"  537","line":"    fn set_reserved_balance(who: &T::AccountId, balance: T::Balance) -> UpdateBalanceOutcome {"},
{"lineNum":"  538","line":"        if balance < T::ExistentialDeposit::get() {"},
{"lineNum":"  539","line":"            <ReservedBalance<T, I>>::insert(who, balance);"},
{"lineNum":"  540","line":"            Self::on_reserved_too_low(who);"},
{"lineNum":"  541","line":"            UpdateBalanceOutcome::AccountKilled"},
{"lineNum":"  542","line":"        } else {"},
{"lineNum":"  543","line":"            <ReservedBalance<T, I>>::insert(who, balance);"},
{"lineNum":"  544","line":"            UpdateBalanceOutcome::Updated"},
{"lineNum":"  545","line":"        }"},
{"lineNum":"  546","line":"    }"},
{"lineNum":"  547","line":""},
{"lineNum":"  548","line":"    /// Set the free balance of an account to some new value. Will enforce `ExistentialDeposit`"},
{"lineNum":"  549","line":"    /// law, annulling the account as needed."},
{"lineNum":"  550","line":"    ///"},
{"lineNum":"  551","line":"    /// Doesn\'t do any preparatory work for creating a new account, so should only be used when it"},
{"lineNum":"  552","line":"    /// is known that the account already exists."},
{"lineNum":"  553","line":"    ///"},
{"lineNum":"  554","line":"    /// NOTE: LOW-LEVEL: This will not attempt to maintain total issuance. It is expected that"},
{"lineNum":"  555","line":"    /// the caller will do this."},
{"lineNum":"  556","line":"    fn set_free_balance(who: &T::AccountId, balance: T::Balance) -> UpdateBalanceOutcome {","class":"lineCov","hits":"3","order":"5291","possible_hits":"3",},
{"lineNum":"  557","line":"        // Commented out for now - but consider it instructive."},
{"lineNum":"  558","line":"        // assert!(!Self::total_balance(who).is_zero());"},
{"lineNum":"  559","line":"        // assert!(Self::free_balance(who) > T::ExistentialDeposit::get());"},
{"lineNum":"  560","line":"        if balance < T::ExistentialDeposit::get() {","class":"linePartCov","hits":"3","order":"5292","possible_hits":"6",},
{"lineNum":"  561","line":"            <FreeBalance<T, I>>::insert(who, balance);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  562","line":"            Self::on_free_too_low(who);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  563","line":"            UpdateBalanceOutcome::AccountKilled","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  564","line":"        } else {"},
{"lineNum":"  565","line":"            <FreeBalance<T, I>>::insert(who, balance);","class":"lineCov","hits":"3","order":"5293","possible_hits":"3",},
{"lineNum":"  566","line":"            UpdateBalanceOutcome::Updated","class":"lineCov","hits":"3","order":"5332","possible_hits":"3",},
{"lineNum":"  567","line":"        }"},
{"lineNum":"  568","line":"    }","class":"linePartCov","hits":"3","order":"5333","possible_hits":"6",},
{"lineNum":"  569","line":""},
{"lineNum":"  570","line":"    /// Register a new account (with existential balance)."},
{"lineNum":"  571","line":"    ///"},
{"lineNum":"  572","line":"    /// This just calls appropriate hooks. It doesn\'t (necessarily) make any state changes."},
{"lineNum":"  573","line":"    fn new_account(who: &T::AccountId, balance: T::Balance) {","class":"lineCov","hits":"2","order":"6558","possible_hits":"2",},
{"lineNum":"  574","line":"        T::OnNewAccount::on_new_account(&who);","class":"lineCov","hits":"2","order":"6559","possible_hits":"2",},
{"lineNum":"  575","line":"        Self::deposit_event(RawEvent::NewAccount(who.clone(), balance));","class":"lineCov","hits":"2","order":"6560","possible_hits":"2",},
{"lineNum":"  576","line":"    }","class":"linePartCov","hits":"2","order":"6561","possible_hits":"4",},
{"lineNum":"  577","line":""},
{"lineNum":"  578","line":"    /// Unregister an account."},
{"lineNum":"  579","line":"    ///"},
{"lineNum":"  580","line":"    /// This just removes the nonce and leaves an event."},
{"lineNum":"  581","line":"    fn reap_account(who: &T::AccountId) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  582","line":"        <system::AccountNonce<T>>::remove(who);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  583","line":"        Self::deposit_event(RawEvent::ReapedAccount(who.clone()));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  584","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  585","line":""},
{"lineNum":"  586","line":"    /// Account\'s free balance has dropped below existential deposit. Kill its"},
{"lineNum":"  587","line":"    /// free side and the account completely if its reserved size is already dead."},
{"lineNum":"  588","line":"    ///"},
{"lineNum":"  589","line":"    /// Will maintain total issuance."},
{"lineNum":"  590","line":"    fn on_free_too_low(who: &T::AccountId) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  591","line":"        let dust = <FreeBalance<T, I>>::take(who);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  592","line":"        <Locks<T, I>>::remove(who);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  593","line":""},
{"lineNum":"  594","line":"        // underflow should never happen, but if it does, there\'s not much we can do about it."},
{"lineNum":"  595","line":"        if !dust.is_zero() {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  596","line":"            T::DustRemoval::on_unbalanced(NegativeImbalance::new(dust));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  597","line":"        }"},
{"lineNum":"  598","line":""},
{"lineNum":"  599","line":"        T::OnFreeBalanceZero::on_free_balance_zero(who);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  600","line":""},
{"lineNum":"  601","line":"        if Self::reserved_balance(who).is_zero() {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  602","line":"            Self::reap_account(who);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  603","line":"        }"},
{"lineNum":"  604","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  605","line":""},
{"lineNum":"  606","line":"    /// Account\'s reserved balance has dropped below existential deposit. Kill its"},
{"lineNum":"  607","line":"    /// reserved side and the account completely if its free size is already dead."},
{"lineNum":"  608","line":"    ///"},
{"lineNum":"  609","line":"    /// Will maintain total issuance."},
{"lineNum":"  610","line":"    fn on_reserved_too_low(who: &T::AccountId) {"},
{"lineNum":"  611","line":"        let dust = <ReservedBalance<T, I>>::take(who);"},
{"lineNum":"  612","line":""},
{"lineNum":"  613","line":"        // underflow should never happen, but it if does, there\'s nothing to be done here."},
{"lineNum":"  614","line":"        if !dust.is_zero() {"},
{"lineNum":"  615","line":"            T::DustRemoval::on_unbalanced(NegativeImbalance::new(dust));"},
{"lineNum":"  616","line":"        }"},
{"lineNum":"  617","line":""},
{"lineNum":"  618","line":"        if Self::free_balance(who).is_zero() {"},
{"lineNum":"  619","line":"            Self::reap_account(who);"},
{"lineNum":"  620","line":"        }"},
{"lineNum":"  621","line":"    }"},
{"lineNum":"  622","line":"}"},
{"lineNum":"  623","line":""},
{"lineNum":"  624","line":"// wrapping these imbalances in a private module is necessary to ensure absolute privacy"},
{"lineNum":"  625","line":"// of the inner member."},
{"lineNum":"  626","line":"mod imbalances {"},
{"lineNum":"  627","line":"    use super::{"},
{"lineNum":"  628","line":"        result, DefaultInstance, Imbalance, Instance, Saturating, StorageValue, Subtrait, Trait,"},
{"lineNum":"  629","line":"        Zero,"},
{"lineNum":"  630","line":"    };"},
{"lineNum":"  631","line":"    use rstd::mem;"},
{"lineNum":"  632","line":""},
{"lineNum":"  633","line":"    /// Opaque, move-only struct with private fields that serves as a token denoting that"},
{"lineNum":"  634","line":"    /// funds have been created without any equal and opposite accounting."},
{"lineNum":"  635","line":"    #[must_use]"},
{"lineNum":"  636","line":"    pub struct PositiveImbalance<T: Subtrait<I>, I: Instance = DefaultInstance>(T::Balance);"},
{"lineNum":"  637","line":""},
{"lineNum":"  638","line":"    impl<T: Subtrait<I>, I: Instance> PositiveImbalance<T, I> {"},
{"lineNum":"  639","line":"        /// Create a new positive imbalance from a balance."},
{"lineNum":"  640","line":"        pub fn new(amount: T::Balance) -> Self {","class":"lineCov","hits":"2","order":"6552","possible_hits":"2",},
{"lineNum":"  641","line":"            PositiveImbalance(amount)","class":"lineCov","hits":"2","order":"6553","possible_hits":"2",},
{"lineNum":"  642","line":"        }","class":"linePartCov","hits":"2","order":"6554","possible_hits":"4",},
{"lineNum":"  643","line":"    }"},
{"lineNum":"  644","line":""},
{"lineNum":"  645","line":"    /// Opaque, move-only struct with private fields that serves as a token denoting that"},
{"lineNum":"  646","line":"    /// funds have been destroyed without any equal and opposite accounting."},
{"lineNum":"  647","line":"    #[must_use]"},
{"lineNum":"  648","line":"    pub struct NegativeImbalance<T: Subtrait<I>, I: Instance = DefaultInstance>(T::Balance);"},
{"lineNum":"  649","line":""},
{"lineNum":"  650","line":"    impl<T: Subtrait<I>, I: Instance> NegativeImbalance<T, I> {"},
{"lineNum":"  651","line":"        /// Create a new negative imbalance from a balance."},
{"lineNum":"  652","line":"        pub fn new(amount: T::Balance) -> Self {","class":"lineCov","hits":"3","order":"5335","possible_hits":"3",},
{"lineNum":"  653","line":"            NegativeImbalance(amount)","class":"lineCov","hits":"3","order":"5336","possible_hits":"3",},
{"lineNum":"  654","line":"        }","class":"linePartCov","hits":"3","order":"5337","possible_hits":"6",},
{"lineNum":"  655","line":"    }"},
{"lineNum":"  656","line":""},
{"lineNum":"  657","line":"    impl<T: Trait<I>, I: Instance> Imbalance<T::Balance> for PositiveImbalance<T, I> {"},
{"lineNum":"  658","line":"        type Opposite = NegativeImbalance<T, I>;"},
{"lineNum":"  659","line":""},
{"lineNum":"  660","line":"        fn zero() -> Self {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  661","line":"            Self(Zero::zero())","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  662","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  663","line":"        fn drop_zero(self) -> result::Result<(), Self> {"},
{"lineNum":"  664","line":"            if self.0.is_zero() {"},
{"lineNum":"  665","line":"                Ok(())"},
{"lineNum":"  666","line":"            } else {"},
{"lineNum":"  667","line":"                Err(self)"},
{"lineNum":"  668","line":"            }"},
{"lineNum":"  669","line":"        }"},
{"lineNum":"  670","line":"        fn split(self, amount: T::Balance) -> (Self, Self) {"},
{"lineNum":"  671","line":"            let first = self.0.min(amount);"},
{"lineNum":"  672","line":"            let second = self.0 - first;"},
{"lineNum":"  673","line":""},
{"lineNum":"  674","line":"            mem::forget(self);"},
{"lineNum":"  675","line":"            (Self(first), Self(second))"},
{"lineNum":"  676","line":"        }"},
{"lineNum":"  677","line":"        fn merge(mut self, other: Self) -> Self {"},
{"lineNum":"  678","line":"            self.0 = self.0.saturating_add(other.0);"},
{"lineNum":"  679","line":"            mem::forget(other);"},
{"lineNum":"  680","line":""},
{"lineNum":"  681","line":"            self"},
{"lineNum":"  682","line":"        }"},
{"lineNum":"  683","line":"        fn subsume(&mut self, other: Self) {"},
{"lineNum":"  684","line":"            self.0 = self.0.saturating_add(other.0);"},
{"lineNum":"  685","line":"            mem::forget(other);"},
{"lineNum":"  686","line":"        }"},
{"lineNum":"  687","line":"        fn offset(self, other: Self::Opposite) -> result::Result<Self, Self::Opposite> {"},
{"lineNum":"  688","line":"            let (a, b) = (self.0, other.0);"},
{"lineNum":"  689","line":"            mem::forget((self, other));"},
{"lineNum":"  690","line":""},
{"lineNum":"  691","line":"            if a >= b {"},
{"lineNum":"  692","line":"                Ok(Self(a - b))"},
{"lineNum":"  693","line":"            } else {"},
{"lineNum":"  694","line":"                Err(NegativeImbalance::new(b - a))"},
{"lineNum":"  695","line":"            }"},
{"lineNum":"  696","line":"        }"},
{"lineNum":"  697","line":"        fn peek(&self) -> T::Balance {"},
{"lineNum":"  698","line":"            self.0.clone()"},
{"lineNum":"  699","line":"        }"},
{"lineNum":"  700","line":"    }"},
{"lineNum":"  701","line":""},
{"lineNum":"  702","line":"    impl<T: Trait<I>, I: Instance> Imbalance<T::Balance> for NegativeImbalance<T, I> {"},
{"lineNum":"  703","line":"        type Opposite = PositiveImbalance<T, I>;"},
{"lineNum":"  704","line":""},
{"lineNum":"  705","line":"        fn zero() -> Self {"},
{"lineNum":"  706","line":"            Self(Zero::zero())"},
{"lineNum":"  707","line":"        }"},
{"lineNum":"  708","line":"        fn drop_zero(self) -> result::Result<(), Self> {"},
{"lineNum":"  709","line":"            if self.0.is_zero() {"},
{"lineNum":"  710","line":"                Ok(())"},
{"lineNum":"  711","line":"            } else {"},
{"lineNum":"  712","line":"                Err(self)"},
{"lineNum":"  713","line":"            }"},
{"lineNum":"  714","line":"        }"},
{"lineNum":"  715","line":"        fn split(self, amount: T::Balance) -> (Self, Self) {"},
{"lineNum":"  716","line":"            let first = self.0.min(amount);"},
{"lineNum":"  717","line":"            let second = self.0 - first;"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"            mem::forget(self);"},
{"lineNum":"  720","line":"            (Self(first), Self(second))"},
{"lineNum":"  721","line":"        }"},
{"lineNum":"  722","line":"        fn merge(mut self, other: Self) -> Self {"},
{"lineNum":"  723","line":"            self.0 = self.0.saturating_add(other.0);"},
{"lineNum":"  724","line":"            mem::forget(other);"},
{"lineNum":"  725","line":""},
{"lineNum":"  726","line":"            self"},
{"lineNum":"  727","line":"        }"},
{"lineNum":"  728","line":"        fn subsume(&mut self, other: Self) {"},
{"lineNum":"  729","line":"            self.0 = self.0.saturating_add(other.0);"},
{"lineNum":"  730","line":"            mem::forget(other);"},
{"lineNum":"  731","line":"        }"},
{"lineNum":"  732","line":"        fn offset(self, other: Self::Opposite) -> result::Result<Self, Self::Opposite> {"},
{"lineNum":"  733","line":"            let (a, b) = (self.0, other.0);"},
{"lineNum":"  734","line":"            mem::forget((self, other));"},
{"lineNum":"  735","line":""},
{"lineNum":"  736","line":"            if a >= b {"},
{"lineNum":"  737","line":"                Ok(Self(a - b))"},
{"lineNum":"  738","line":"            } else {"},
{"lineNum":"  739","line":"                Err(PositiveImbalance::new(b - a))"},
{"lineNum":"  740","line":"            }"},
{"lineNum":"  741","line":"        }"},
{"lineNum":"  742","line":"        fn peek(&self) -> T::Balance {"},
{"lineNum":"  743","line":"            self.0.clone()"},
{"lineNum":"  744","line":"        }"},
{"lineNum":"  745","line":"    }"},
{"lineNum":"  746","line":""},
{"lineNum":"  747","line":"    impl<T: Subtrait<I>, I: Instance> Drop for PositiveImbalance<T, I> {"},
{"lineNum":"  748","line":"        /// Basic drop handler will just square up the total issuance."},
{"lineNum":"  749","line":"        fn drop(&mut self) {","class":"lineCov","hits":"2","order":"6566","possible_hits":"2",},
{"lineNum":"  750","line":"            <super::TotalIssuance<super::ElevatedTrait<T, I>, I>>::mutate(|v| {","class":"lineCov","hits":"4","order":"6567","possible_hits":"4",},
{"lineNum":"  751","line":"                *v = v.saturating_add(self.0)","class":"lineCov","hits":"2","order":"6568","possible_hits":"2",},
{"lineNum":"  752","line":"            });","class":"linePartCov","hits":"2","order":"6569","possible_hits":"4",},
{"lineNum":"  753","line":"        }","class":"linePartCov","hits":"2","order":"6570","possible_hits":"4",},
{"lineNum":"  754","line":"    }"},
{"lineNum":"  755","line":""},
{"lineNum":"  756","line":"    impl<T: Subtrait<I>, I: Instance> Drop for NegativeImbalance<T, I> {"},
{"lineNum":"  757","line":"        /// Basic drop handler will just square up the total issuance."},
{"lineNum":"  758","line":"        fn drop(&mut self) {","class":"lineCov","hits":"3","order":"5438","possible_hits":"3",},
{"lineNum":"  759","line":"            <super::TotalIssuance<super::ElevatedTrait<T, I>, I>>::mutate(|v| {","class":"lineCov","hits":"6","order":"5439","possible_hits":"6",},
{"lineNum":"  760","line":"                *v = v.saturating_sub(self.0)","class":"lineCov","hits":"3","order":"5440","possible_hits":"3",},
{"lineNum":"  761","line":"            });","class":"linePartCov","hits":"3","order":"5443","possible_hits":"6",},
{"lineNum":"  762","line":"        }","class":"linePartCov","hits":"3","order":"5444","possible_hits":"6",},
{"lineNum":"  763","line":"    }"},
{"lineNum":"  764","line":"}"},
{"lineNum":"  765","line":""},
{"lineNum":"  766","line":"// TODO: #2052"},
{"lineNum":"  767","line":"// Somewhat ugly hack in order to gain access to module\'s `increase_total_issuance_by`"},
{"lineNum":"  768","line":"// using only the Subtrait (which defines only the types that are not dependent"},
{"lineNum":"  769","line":"// on Positive/NegativeImbalance). Subtrait must be used otherwise we end up with a"},
{"lineNum":"  770","line":"// circular dependency with Trait having some types be dependent on PositiveImbalance<Trait>"},
{"lineNum":"  771","line":"// and PositiveImbalance itself depending back on Trait for its Drop impl (and thus"},
{"lineNum":"  772","line":"// its type declaration)."},
{"lineNum":"  773","line":"// This works as long as `increase_total_issuance_by` doesn\'t use the Imbalance"},
{"lineNum":"  774","line":"// types (basically for charging fees)."},
{"lineNum":"  775","line":"// This should eventually be refactored so that the three type items that do"},
{"lineNum":"  776","line":"// depend on the Imbalance type (TransactionPayment, TransferPayment, DustRemoval)"},
{"lineNum":"  777","line":"// are placed in their own SRML module."},
{"lineNum":"  778","line":"struct ElevatedTrait<T: Subtrait<I>, I: Instance>(T, I);"},
{"lineNum":"  779","line":"impl<T: Subtrait<I>, I: Instance> Clone for ElevatedTrait<T, I> {"},
{"lineNum":"  780","line":"    fn clone(&self) -> Self {"},
{"lineNum":"  781","line":"        unimplemented!()"},
{"lineNum":"  782","line":"    }"},
{"lineNum":"  783","line":"}"},
{"lineNum":"  784","line":"impl<T: Subtrait<I>, I: Instance> PartialEq for ElevatedTrait<T, I> {"},
{"lineNum":"  785","line":"    fn eq(&self, _: &Self) -> bool {"},
{"lineNum":"  786","line":"        unimplemented!()"},
{"lineNum":"  787","line":"    }"},
{"lineNum":"  788","line":"}"},
{"lineNum":"  789","line":"impl<T: Subtrait<I>, I: Instance> Eq for ElevatedTrait<T, I> {}"},
{"lineNum":"  790","line":"impl<T: Subtrait<I>, I: Instance> system::Trait for ElevatedTrait<T, I> {"},
{"lineNum":"  791","line":"    type Origin = T::Origin;"},
{"lineNum":"  792","line":"    type Call = T::Call;"},
{"lineNum":"  793","line":"    type Index = T::Index;"},
{"lineNum":"  794","line":"    type BlockNumber = T::BlockNumber;"},
{"lineNum":"  795","line":"    type Hash = T::Hash;"},
{"lineNum":"  796","line":"    type Hashing = T::Hashing;"},
{"lineNum":"  797","line":"    type AccountId = T::AccountId;"},
{"lineNum":"  798","line":"    type Lookup = T::Lookup;"},
{"lineNum":"  799","line":"    type Header = T::Header;"},
{"lineNum":"  800","line":"    type WeightMultiplierUpdate = T::WeightMultiplierUpdate;"},
{"lineNum":"  801","line":"    type Event = ();"},
{"lineNum":"  802","line":"    type BlockHashCount = T::BlockHashCount;"},
{"lineNum":"  803","line":"    type MaximumBlockWeight = T::MaximumBlockWeight;"},
{"lineNum":"  804","line":"    type MaximumBlockLength = T::MaximumBlockLength;"},
{"lineNum":"  805","line":"    type AvailableBlockRatio = T::AvailableBlockRatio;"},
{"lineNum":"  806","line":"    type Version = T::Version;"},
{"lineNum":"  807","line":"}"},
{"lineNum":"  808","line":"impl<T: Subtrait<I>, I: Instance> Trait<I> for ElevatedTrait<T, I> {"},
{"lineNum":"  809","line":"    type Balance = T::Balance;"},
{"lineNum":"  810","line":"    type OnFreeBalanceZero = T::OnFreeBalanceZero;"},
{"lineNum":"  811","line":"    type OnNewAccount = T::OnNewAccount;"},
{"lineNum":"  812","line":"    type Event = ();"},
{"lineNum":"  813","line":"    type TransactionPayment = ();"},
{"lineNum":"  814","line":"    type TransferPayment = ();"},
{"lineNum":"  815","line":"    type DustRemoval = ();"},
{"lineNum":"  816","line":"    type ExistentialDeposit = T::ExistentialDeposit;"},
{"lineNum":"  817","line":"    type TransferFee = T::TransferFee;"},
{"lineNum":"  818","line":"    type CreationFee = T::CreationFee;"},
{"lineNum":"  819","line":"    type TransactionBaseFee = T::TransactionBaseFee;"},
{"lineNum":"  820","line":"    type TransactionByteFee = T::TransactionByteFee;"},
{"lineNum":"  821","line":"    type WeightToFee = T::WeightToFee;"},
{"lineNum":"  822","line":"    type Identity = T::Identity;"},
{"lineNum":"  823","line":"}"},
{"lineNum":"  824","line":""},
{"lineNum":"  825","line":"impl<T: Trait<I>, I: Instance> Currency<T::AccountId> for Module<T, I>"},
{"lineNum":"  826","line":"where"},
{"lineNum":"  827","line":"    T::Balance: MaybeSerializeDebug,"},
{"lineNum":"  828","line":"{"},
{"lineNum":"  829","line":"    type Balance = T::Balance;"},
{"lineNum":"  830","line":"    type PositiveImbalance = PositiveImbalance<T, I>;"},
{"lineNum":"  831","line":"    type NegativeImbalance = NegativeImbalance<T, I>;"},
{"lineNum":"  832","line":""},
{"lineNum":"  833","line":"    fn total_balance(who: &T::AccountId) -> Self::Balance {"},
{"lineNum":"  834","line":"        Self::free_balance(who) + Self::reserved_balance(who)"},
{"lineNum":"  835","line":"    }"},
{"lineNum":"  836","line":""},
{"lineNum":"  837","line":"    fn can_slash(who: &T::AccountId, value: Self::Balance) -> bool {"},
{"lineNum":"  838","line":"        Self::free_balance(who) >= value"},
{"lineNum":"  839","line":"    }"},
{"lineNum":"  840","line":""},
{"lineNum":"  841","line":"    fn total_issuance() -> Self::Balance {"},
{"lineNum":"  842","line":"        <TotalIssuance<T, I>>::get()"},
{"lineNum":"  843","line":"    }"},
{"lineNum":"  844","line":""},
{"lineNum":"  845","line":"    fn minimum_balance() -> Self::Balance {"},
{"lineNum":"  846","line":"        T::ExistentialDeposit::get()"},
{"lineNum":"  847","line":"    }"},
{"lineNum":"  848","line":""},
{"lineNum":"  849","line":"    fn free_balance(who: &T::AccountId) -> Self::Balance {"},
{"lineNum":"  850","line":"        <FreeBalance<T, I>>::get(who)"},
{"lineNum":"  851","line":"    }"},
{"lineNum":"  852","line":""},
{"lineNum":"  853","line":"    fn burn(mut amount: Self::Balance) -> Self::PositiveImbalance {"},
{"lineNum":"  854","line":"        <TotalIssuance<T, I>>::mutate(|issued| {"},
{"lineNum":"  855","line":"            *issued = issued.checked_sub(&amount).unwrap_or_else(|| {"},
{"lineNum":"  856","line":"                amount = *issued;"},
{"lineNum":"  857","line":"                Zero::zero()"},
{"lineNum":"  858","line":"            });"},
{"lineNum":"  859","line":"        });"},
{"lineNum":"  860","line":"        PositiveImbalance::new(amount)"},
{"lineNum":"  861","line":"    }"},
{"lineNum":"  862","line":""},
{"lineNum":"  863","line":"    fn issue(mut amount: Self::Balance) -> Self::NegativeImbalance {"},
{"lineNum":"  864","line":"        <TotalIssuance<T, I>>::mutate(|issued| {"},
{"lineNum":"  865","line":"            *issued = issued.checked_add(&amount).unwrap_or_else(|| {"},
{"lineNum":"  866","line":"                amount = Self::Balance::max_value() - *issued;"},
{"lineNum":"  867","line":"                Self::Balance::max_value()"},
{"lineNum":"  868","line":"            })"},
{"lineNum":"  869","line":"        });"},
{"lineNum":"  870","line":"        NegativeImbalance::new(amount)"},
{"lineNum":"  871","line":"    }"},
{"lineNum":"  872","line":""},
{"lineNum":"  873","line":"    // # <weight>"},
{"lineNum":"  874","line":"    // Despite iterating over a list of locks, they are limited by the number of"},
{"lineNum":"  875","line":"    // lock IDs, which means the number of runtime modules that intend to use and create locks."},
{"lineNum":"  876","line":"    // # </weight>"},
{"lineNum":"  877","line":"    fn ensure_can_withdraw(","class":"linePartCov","hits":"3","order":"5281","possible_hits":"6",},
{"lineNum":"  878","line":"        who: &T::AccountId,"},
{"lineNum":"  879","line":"        _amount: T::Balance,"},
{"lineNum":"  880","line":"        reason: WithdrawReason,"},
{"lineNum":"  881","line":"        new_balance: T::Balance,"},
{"lineNum":"  882","line":"    ) -> Result {"},
{"lineNum":"  883","line":"        match reason {","class":"linePartCov","hits":"3","order":"5282","possible_hits":"9",},
{"lineNum":"  884","line":"            WithdrawReason::Reserve | WithdrawReason::Transfer","class":"linePartCov","hits":"3","order":"5283","possible_hits":"9",},
{"lineNum":"  885","line":"                if Self::vesting_balance(who) > new_balance =>","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  886","line":"            {"},
{"lineNum":"  887","line":"                return Err(\"vesting balance too high to send value\")","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  888","line":"            }"},
{"lineNum":"  889","line":"            _ => {}"},
{"lineNum":"  890","line":"        }"},
{"lineNum":"  891","line":"        let locks = Self::locks(who);","class":"lineCov","hits":"3","order":"5284","possible_hits":"3",},
{"lineNum":"  892","line":"        if locks.is_empty() {","class":"lineCov","hits":"3","order":"5285","possible_hits":"3",},
{"lineNum":"  893","line":"            return Ok(());","class":"lineCov","hits":"6","order":"5288","possible_hits":"6",},
{"lineNum":"  894","line":"        }"},
{"lineNum":"  895","line":""},
{"lineNum":"  896","line":"        let now = <system::Module<T>>::block_number();","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  897","line":"        if locks","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  898","line":"            .into_iter()"},
{"lineNum":"  899","line":"            .all(|l| now >= l.until || new_balance >= l.amount || !l.reasons.contains(reason))","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  900","line":"        {"},
{"lineNum":"  901","line":"            Ok(())","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  902","line":"        } else {"},
{"lineNum":"  903","line":"            Err(\"account liquidity restrictions prevent withdrawal\")","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  904","line":"        }"},
{"lineNum":"  905","line":"    }","class":"linePartCov","hits":"6","order":"5289","possible_hits":"9",},
{"lineNum":"  906","line":""},
{"lineNum":"  907","line":"    fn transfer(transactor: &T::AccountId, dest: &T::AccountId, value: Self::Balance) -> Result {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  908","line":"        let from_balance = Self::free_balance(transactor);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  909","line":"        let to_balance = Self::free_balance(dest);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  910","line":"        let would_create = to_balance.is_zero();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  911","line":"        let fee = if would_create {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  912","line":"            T::CreationFee::get()","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  913","line":"        } else {"},
{"lineNum":"  914","line":"            T::TransferFee::get()","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  915","line":"        };"},
{"lineNum":"  916","line":"        let liability = match value.checked_add(&fee) {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  917","line":"            Some(l) => l,","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  918","line":"            None => return Err(\"got overflow after adding a fee to value\"),","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  919","line":"        };"},
{"lineNum":"  920","line":""},
{"lineNum":"  921","line":"        let new_from_balance = match from_balance.checked_sub(&liability) {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  922","line":"            None => return Err(\"balance too low to send value\"),","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  923","line":"            Some(b) => b,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  924","line":"        };"},
{"lineNum":"  925","line":"        if would_create && value < T::ExistentialDeposit::get() {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  926","line":"            return Err(\"value too low to create account\");","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  927","line":"        }"},
{"lineNum":"  928","line":"        Self::ensure_can_withdraw(","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  929","line":"            transactor,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  930","line":"            value,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  931","line":"            WithdrawReason::Transfer,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  932","line":"            new_from_balance,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  933","line":"        )?;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  934","line":""},
{"lineNum":"  935","line":"        // NOTE: total stake being stored in the same type means that this could never overflow"},
{"lineNum":"  936","line":"        // but better to be safe than sorry."},
{"lineNum":"  937","line":"        let new_to_balance = match to_balance.checked_add(&value) {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  938","line":"            Some(b) => b,","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  939","line":"            None => return Err(\"destination balance too high to receive value\"),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  940","line":"        };"},
{"lineNum":"  941","line":""},
{"lineNum":"  942","line":"        if transactor != dest {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  943","line":"            Self::set_free_balance(transactor, new_from_balance);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  944","line":"            if !<FreeBalance<T, I>>::exists(dest) {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  945","line":"                Self::new_account(dest, new_to_balance);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  946","line":"            }"},
{"lineNum":"  947","line":"            Self::set_free_balance(dest, new_to_balance);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  948","line":"            T::TransferPayment::on_unbalanced(NegativeImbalance::new(fee));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  949","line":"            Self::deposit_event(RawEvent::Transfer(","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  950","line":"                transactor.clone(),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  951","line":"                dest.clone(),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  952","line":"                value,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  953","line":"                fee,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  954","line":"            ));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  955","line":"        }"},
{"lineNum":"  956","line":""},
{"lineNum":"  957","line":"        Ok(())","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  958","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  959","line":""},
{"lineNum":"  960","line":"    fn withdraw(","class":"lineCov","hits":"3","order":"5266","possible_hits":"3",},
{"lineNum":"  961","line":"        who: &T::AccountId,"},
{"lineNum":"  962","line":"        value: Self::Balance,"},
{"lineNum":"  963","line":"        reason: WithdrawReason,"},
{"lineNum":"  964","line":"        liveness: ExistenceRequirement,"},
{"lineNum":"  965","line":"    ) -> result::Result<Self::NegativeImbalance, &\'static str> {"},
{"lineNum":"  966","line":"        if let Some(new_balance) = Self::free_balance(who).checked_sub(&value) {","class":"linePartCov","hits":"3","order":"5267","possible_hits":"6",},
{"lineNum":"  967","line":"            if liveness == ExistenceRequirement::KeepAlive","class":"lineCov","hits":"9","order":"5277","possible_hits":"9",},
{"lineNum":"  968","line":"                && new_balance < T::ExistentialDeposit::get()","class":"lineCov","hits":"6","order":"5278","possible_hits":"6",},
{"lineNum":"  969","line":"            {"},
{"lineNum":"  970","line":"                return Err(\"payment would kill account\");","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  971","line":"            }"},
{"lineNum":"  972","line":"            Self::ensure_can_withdraw(who, value, reason, new_balance)?;","class":"lineCov","hits":"6","order":"5280","possible_hits":"6",},
{"lineNum":"  973","line":"            Self::set_free_balance(who, new_balance);","class":"lineCov","hits":"3","order":"5290","possible_hits":"3",},
{"lineNum":"  974","line":"            Ok(NegativeImbalance::new(value))","class":"lineCov","hits":"3","order":"5334","possible_hits":"3",},
{"lineNum":"  975","line":"        } else {"},
{"lineNum":"  976","line":"            Err(\"too few free funds in account\")","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  977","line":"        }"},
{"lineNum":"  978","line":"    }","class":"linePartCov","hits":"6","order":"5338","possible_hits":"9",},
{"lineNum":"  979","line":""},
{"lineNum":"  980","line":"    fn slash(who: &T::AccountId, value: Self::Balance) -> (Self::NegativeImbalance, Self::Balance) {"},
{"lineNum":"  981","line":"        let free_balance = Self::free_balance(who);"},
{"lineNum":"  982","line":"        let free_slash = cmp::min(free_balance, value);"},
{"lineNum":"  983","line":"        Self::set_free_balance(who, free_balance - free_slash);"},
{"lineNum":"  984","line":"        let remaining_slash = value - free_slash;"},
{"lineNum":"  985","line":"        // NOTE: `slash()` prefers free balance, but assumes that reserve balance can be drawn"},
{"lineNum":"  986","line":"        // from in extreme circumstances. `can_slash()` should be used prior to `slash()` to avoid having"},
{"lineNum":"  987","line":"        // to draw from reserved funds, however we err on the side of punishment if things are inconsistent"},
{"lineNum":"  988","line":"        // or `can_slash` wasn\'t used appropriately."},
{"lineNum":"  989","line":"        if !remaining_slash.is_zero() {"},
{"lineNum":"  990","line":"            let reserved_balance = Self::reserved_balance(who);"},
{"lineNum":"  991","line":"            let reserved_slash = cmp::min(reserved_balance, remaining_slash);"},
{"lineNum":"  992","line":"            Self::set_reserved_balance(who, reserved_balance - reserved_slash);"},
{"lineNum":"  993","line":"            ("},
{"lineNum":"  994","line":"                NegativeImbalance::new(free_slash + reserved_slash),"},
{"lineNum":"  995","line":"                remaining_slash - reserved_slash,"},
{"lineNum":"  996","line":"            )"},
{"lineNum":"  997","line":"        } else {"},
{"lineNum":"  998","line":"            (NegativeImbalance::new(value), Zero::zero())"},
{"lineNum":"  999","line":"        }"},
{"lineNum":" 1000","line":"    }"},
{"lineNum":" 1001","line":""},
{"lineNum":" 1002","line":"    fn deposit_into_existing("},
{"lineNum":" 1003","line":"        who: &T::AccountId,"},
{"lineNum":" 1004","line":"        value: Self::Balance,"},
{"lineNum":" 1005","line":"    ) -> result::Result<Self::PositiveImbalance, &\'static str> {"},
{"lineNum":" 1006","line":"        if Self::total_balance(who).is_zero() {"},
{"lineNum":" 1007","line":"            return Err(\"beneficiary account must pre-exist\");"},
{"lineNum":" 1008","line":"        }"},
{"lineNum":" 1009","line":"        Self::set_free_balance(who, Self::free_balance(who) + value);"},
{"lineNum":" 1010","line":"        Ok(PositiveImbalance::new(value))"},
{"lineNum":" 1011","line":"    }"},
{"lineNum":" 1012","line":""},
{"lineNum":" 1013","line":"    fn deposit_creating(who: &T::AccountId, value: Self::Balance) -> Self::PositiveImbalance {"},
{"lineNum":" 1014","line":"        let (imbalance, _) = Self::make_free_balance_be(who, Self::free_balance(who) + value);"},
{"lineNum":" 1015","line":"        if let SignedImbalance::Positive(p) = imbalance {"},
{"lineNum":" 1016","line":"            p"},
{"lineNum":" 1017","line":"        } else {"},
{"lineNum":" 1018","line":"            // Impossible, but be defensive."},
{"lineNum":" 1019","line":"            Self::PositiveImbalance::zero()"},
{"lineNum":" 1020","line":"        }"},
{"lineNum":" 1021","line":"    }"},
{"lineNum":" 1022","line":""},
{"lineNum":" 1023","line":"    fn make_free_balance_be(","class":"linePartCov","hits":"2","order":"6546","possible_hits":"4",},
{"lineNum":" 1024","line":"        who: &T::AccountId,"},
{"lineNum":" 1025","line":"        balance: Self::Balance,"},
{"lineNum":" 1026","line":"    ) -> ("},
{"lineNum":" 1027","line":"        SignedImbalance<Self::Balance, Self::PositiveImbalance>,"},
{"lineNum":" 1028","line":"        UpdateBalanceOutcome,"},
{"lineNum":" 1029","line":"    ) {"},
{"lineNum":" 1030","line":"        let original = Self::free_balance(who);","class":"lineCov","hits":"2","order":"6547","possible_hits":"2",},
{"lineNum":" 1031","line":"        if balance < T::ExistentialDeposit::get() && original.is_zero() {","class":"lineCov","hits":"2","order":"6548","possible_hits":"2",},
{"lineNum":" 1032","line":"            // If we\'re attempting to set an existing account to less than ED, then"},
{"lineNum":" 1033","line":"            // bypass the entire operation. It\'s a no-op if you follow it through, but"},
{"lineNum":" 1034","line":"            // since this is an instance where we might account for a negative imbalance"},
{"lineNum":" 1035","line":"            // (in the dust cleaner of set_free_balance) before we account for its actual"},
{"lineNum":" 1036","line":"            // equal and opposite cause (returned as an Imbalance), then in the"},
{"lineNum":" 1037","line":"            // instance that there\'s no other accounts on the system at all, we might"},
{"lineNum":" 1038","line":"            // underflow the issuance and our arithmetic will be off."},
{"lineNum":" 1039","line":"            return (","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1040","line":"                SignedImbalance::Positive(Self::PositiveImbalance::zero()),","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1041","line":"                UpdateBalanceOutcome::AccountKilled,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1042","line":"            );"},
{"lineNum":" 1043","line":"        }"},
{"lineNum":" 1044","line":"        let imbalance = if original <= balance {","class":"lineCov","hits":"6","order":"6549","possible_hits":"6",},
{"lineNum":" 1045","line":"            SignedImbalance::Positive(PositiveImbalance::new(balance - original))","class":"lineCov","hits":"2","order":"6551","possible_hits":"2",},
{"lineNum":" 1046","line":"        } else {"},
{"lineNum":" 1047","line":"            SignedImbalance::Negative(NegativeImbalance::new(original - balance))","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1048","line":"        };"},
{"lineNum":" 1049","line":"        // If the balance is too low, then the account is reaped."},
{"lineNum":" 1050","line":"        // NOTE: There are two balances for every account: `reserved_balance` and"},
{"lineNum":" 1051","line":"        // `free_balance`. This contract subsystem only cares about the latter: whenever"},
{"lineNum":" 1052","line":"        // the term \"balance\" is used *here* it should be assumed to mean \"free balance\""},
{"lineNum":" 1053","line":"        // in the rest of the module."},
{"lineNum":" 1054","line":"        // Free balance can never be less than ED. If that happens, it gets reduced to zero"},
{"lineNum":" 1055","line":"        // and the account information relevant to this subsystem is deleted (i.e. the"},
{"lineNum":" 1056","line":"        // account is reaped)."},
{"lineNum":" 1057","line":"        let outcome = if balance < T::ExistentialDeposit::get() {","class":"linePartCov","hits":"4","order":"6555","possible_hits":"6",},
{"lineNum":" 1058","line":"            Self::set_free_balance(who, balance);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1059","line":"            UpdateBalanceOutcome::AccountKilled","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1060","line":"        } else {"},
{"lineNum":" 1061","line":"            if !<FreeBalance<T, I>>::exists(who) {","class":"lineCov","hits":"6","order":"6556","possible_hits":"6",},
{"lineNum":" 1062","line":"                Self::new_account(&who, balance);","class":"lineCov","hits":"2","order":"6557","possible_hits":"2",},
{"lineNum":" 1063","line":"            }"},
{"lineNum":" 1064","line":"            Self::set_free_balance(who, balance);","class":"lineCov","hits":"2","order":"6562","possible_hits":"2",},
{"lineNum":" 1065","line":"            UpdateBalanceOutcome::Updated","class":"lineCov","hits":"2","order":"6563","possible_hits":"2",},
{"lineNum":" 1066","line":"        };"},
{"lineNum":" 1067","line":"        (imbalance, outcome)","class":"lineCov","hits":"2","order":"6564","possible_hits":"2",},
{"lineNum":" 1068","line":"    }","class":"linePartCov","hits":"4","order":"6565","possible_hits":"6",},
{"lineNum":" 1069","line":"}"},
{"lineNum":" 1070","line":""},
{"lineNum":" 1071","line":"impl<T: Trait<I>, I: Instance> ReservableCurrency<T::AccountId> for Module<T, I>"},
{"lineNum":" 1072","line":"where"},
{"lineNum":" 1073","line":"    T::Balance: MaybeSerializeDebug,"},
{"lineNum":" 1074","line":"{"},
{"lineNum":" 1075","line":"    fn can_reserve(who: &T::AccountId, value: Self::Balance) -> bool {"},
{"lineNum":" 1076","line":"        Self::free_balance(who)"},
{"lineNum":" 1077","line":"            .checked_sub(&value)"},
{"lineNum":" 1078","line":"            .map_or(false, |new_balance| {"},
{"lineNum":" 1079","line":"                Self::ensure_can_withdraw(who, value, WithdrawReason::Reserve, new_balance).is_ok()"},
{"lineNum":" 1080","line":"            })"},
{"lineNum":" 1081","line":"    }"},
{"lineNum":" 1082","line":""},
{"lineNum":" 1083","line":"    fn reserved_balance(who: &T::AccountId) -> Self::Balance {"},
{"lineNum":" 1084","line":"        <ReservedBalance<T, I>>::get(who)"},
{"lineNum":" 1085","line":"    }"},
{"lineNum":" 1086","line":""},
{"lineNum":" 1087","line":"    fn reserve(who: &T::AccountId, value: Self::Balance) -> result::Result<(), &\'static str> {"},
{"lineNum":" 1088","line":"        let b = Self::free_balance(who);"},
{"lineNum":" 1089","line":"        if b < value {"},
{"lineNum":" 1090","line":"            return Err(\"not enough free funds\");"},
{"lineNum":" 1091","line":"        }"},
{"lineNum":" 1092","line":"        let new_balance = b - value;"},
{"lineNum":" 1093","line":"        Self::ensure_can_withdraw(who, value, WithdrawReason::Reserve, new_balance)?;"},
{"lineNum":" 1094","line":"        Self::set_reserved_balance(who, Self::reserved_balance(who) + value);"},
{"lineNum":" 1095","line":"        Self::set_free_balance(who, new_balance);"},
{"lineNum":" 1096","line":"        Ok(())"},
{"lineNum":" 1097","line":"    }"},
{"lineNum":" 1098","line":""},
{"lineNum":" 1099","line":"    fn unreserve(who: &T::AccountId, value: Self::Balance) -> Self::Balance {"},
{"lineNum":" 1100","line":"        let b = Self::reserved_balance(who);"},
{"lineNum":" 1101","line":"        let actual = cmp::min(b, value);"},
{"lineNum":" 1102","line":"        Self::set_free_balance(who, Self::free_balance(who) + actual);"},
{"lineNum":" 1103","line":"        Self::set_reserved_balance(who, b - actual);"},
{"lineNum":" 1104","line":"        value - actual"},
{"lineNum":" 1105","line":"    }"},
{"lineNum":" 1106","line":""},
{"lineNum":" 1107","line":"    fn slash_reserved("},
{"lineNum":" 1108","line":"        who: &T::AccountId,"},
{"lineNum":" 1109","line":"        value: Self::Balance,"},
{"lineNum":" 1110","line":"    ) -> (Self::NegativeImbalance, Self::Balance) {"},
{"lineNum":" 1111","line":"        let b = Self::reserved_balance(who);"},
{"lineNum":" 1112","line":"        let slash = cmp::min(b, value);"},
{"lineNum":" 1113","line":"        // underflow should never happen, but it if does, there\'s nothing to be done here."},
{"lineNum":" 1114","line":"        Self::set_reserved_balance(who, b - slash);"},
{"lineNum":" 1115","line":"        (NegativeImbalance::new(slash), value - slash)"},
{"lineNum":" 1116","line":"    }"},
{"lineNum":" 1117","line":""},
{"lineNum":" 1118","line":"    fn repatriate_reserved("},
{"lineNum":" 1119","line":"        slashed: &T::AccountId,"},
{"lineNum":" 1120","line":"        beneficiary: &T::AccountId,"},
{"lineNum":" 1121","line":"        value: Self::Balance,"},
{"lineNum":" 1122","line":"    ) -> result::Result<Self::Balance, &\'static str> {"},
{"lineNum":" 1123","line":"        if Self::total_balance(beneficiary).is_zero() {"},
{"lineNum":" 1124","line":"            return Err(\"beneficiary account must pre-exist\");"},
{"lineNum":" 1125","line":"        }"},
{"lineNum":" 1126","line":"        let b = Self::reserved_balance(slashed);"},
{"lineNum":" 1127","line":"        let slash = cmp::min(b, value);"},
{"lineNum":" 1128","line":"        Self::set_free_balance(beneficiary, Self::free_balance(beneficiary) + slash);"},
{"lineNum":" 1129","line":"        Self::set_reserved_balance(slashed, b - slash);"},
{"lineNum":" 1130","line":"        Ok(value - slash)"},
{"lineNum":" 1131","line":"    }"},
{"lineNum":" 1132","line":"}"},
{"lineNum":" 1133","line":""},
{"lineNum":" 1134","line":"impl<T: Trait<I>, I: Instance> LockableCurrency<T::AccountId> for Module<T, I>"},
{"lineNum":" 1135","line":"where"},
{"lineNum":" 1136","line":"    T::Balance: MaybeSerializeDebug,"},
{"lineNum":" 1137","line":"{"},
{"lineNum":" 1138","line":"    type Moment = T::BlockNumber;"},
{"lineNum":" 1139","line":""},
{"lineNum":" 1140","line":"    fn set_lock("},
{"lineNum":" 1141","line":"        id: LockIdentifier,"},
{"lineNum":" 1142","line":"        who: &T::AccountId,"},
{"lineNum":" 1143","line":"        amount: T::Balance,"},
{"lineNum":" 1144","line":"        until: T::BlockNumber,"},
{"lineNum":" 1145","line":"        reasons: WithdrawReasons,"},
{"lineNum":" 1146","line":"    ) {"},
{"lineNum":" 1147","line":"        let now = <system::Module<T>>::block_number();"},
{"lineNum":" 1148","line":"        let mut new_lock = Some(BalanceLock {"},
{"lineNum":" 1149","line":"            id,"},
{"lineNum":" 1150","line":"            amount,"},
{"lineNum":" 1151","line":"            until,"},
{"lineNum":" 1152","line":"            reasons,"},
{"lineNum":" 1153","line":"        });"},
{"lineNum":" 1154","line":"        let mut locks = Self::locks(who)"},
{"lineNum":" 1155","line":"            .into_iter()"},
{"lineNum":" 1156","line":"            .filter_map(|l| {"},
{"lineNum":" 1157","line":"                if l.id == id {"},
{"lineNum":" 1158","line":"                    new_lock.take()"},
{"lineNum":" 1159","line":"                } else if l.until > now {"},
{"lineNum":" 1160","line":"                    Some(l)"},
{"lineNum":" 1161","line":"                } else {"},
{"lineNum":" 1162","line":"                    None"},
{"lineNum":" 1163","line":"                }"},
{"lineNum":" 1164","line":"            })"},
{"lineNum":" 1165","line":"            .collect::<Vec<_>>();"},
{"lineNum":" 1166","line":"        if let Some(lock) = new_lock {"},
{"lineNum":" 1167","line":"            locks.push(lock)"},
{"lineNum":" 1168","line":"        }"},
{"lineNum":" 1169","line":"        <Locks<T, I>>::insert(who, locks);"},
{"lineNum":" 1170","line":"    }"},
{"lineNum":" 1171","line":""},
{"lineNum":" 1172","line":"    fn extend_lock("},
{"lineNum":" 1173","line":"        id: LockIdentifier,"},
{"lineNum":" 1174","line":"        who: &T::AccountId,"},
{"lineNum":" 1175","line":"        amount: T::Balance,"},
{"lineNum":" 1176","line":"        until: T::BlockNumber,"},
{"lineNum":" 1177","line":"        reasons: WithdrawReasons,"},
{"lineNum":" 1178","line":"    ) {"},
{"lineNum":" 1179","line":"        let now = <system::Module<T>>::block_number();"},
{"lineNum":" 1180","line":"        let mut new_lock = Some(BalanceLock {"},
{"lineNum":" 1181","line":"            id,"},
{"lineNum":" 1182","line":"            amount,"},
{"lineNum":" 1183","line":"            until,"},
{"lineNum":" 1184","line":"            reasons,"},
{"lineNum":" 1185","line":"        });"},
{"lineNum":" 1186","line":"        let mut locks = Self::locks(who)"},
{"lineNum":" 1187","line":"            .into_iter()"},
{"lineNum":" 1188","line":"            .filter_map(|l| {"},
{"lineNum":" 1189","line":"                if l.id == id {"},
{"lineNum":" 1190","line":"                    new_lock.take().map(|nl| BalanceLock {"},
{"lineNum":" 1191","line":"                        id: l.id,"},
{"lineNum":" 1192","line":"                        amount: l.amount.max(nl.amount),"},
{"lineNum":" 1193","line":"                        until: l.until.max(nl.until),"},
{"lineNum":" 1194","line":"                        reasons: l.reasons | nl.reasons,"},
{"lineNum":" 1195","line":"                    })"},
{"lineNum":" 1196","line":"                } else if l.until > now {"},
{"lineNum":" 1197","line":"                    Some(l)"},
{"lineNum":" 1198","line":"                } else {"},
{"lineNum":" 1199","line":"                    None"},
{"lineNum":" 1200","line":"                }"},
{"lineNum":" 1201","line":"            })"},
{"lineNum":" 1202","line":"            .collect::<Vec<_>>();"},
{"lineNum":" 1203","line":"        if let Some(lock) = new_lock {"},
{"lineNum":" 1204","line":"            locks.push(lock)"},
{"lineNum":" 1205","line":"        }"},
{"lineNum":" 1206","line":"        <Locks<T, I>>::insert(who, locks);"},
{"lineNum":" 1207","line":"    }"},
{"lineNum":" 1208","line":""},
{"lineNum":" 1209","line":"    fn remove_lock(id: LockIdentifier, who: &T::AccountId) {"},
{"lineNum":" 1210","line":"        let now = <system::Module<T>>::block_number();"},
{"lineNum":" 1211","line":"        let locks = Self::locks(who)"},
{"lineNum":" 1212","line":"            .into_iter()"},
{"lineNum":" 1213","line":"            .filter_map(|l| {"},
{"lineNum":" 1214","line":"                if l.until > now && l.id != id {"},
{"lineNum":" 1215","line":"                    Some(l)"},
{"lineNum":" 1216","line":"                } else {"},
{"lineNum":" 1217","line":"                    None"},
{"lineNum":" 1218","line":"                }"},
{"lineNum":" 1219","line":"            })"},
{"lineNum":" 1220","line":"            .collect::<Vec<_>>();"},
{"lineNum":" 1221","line":"        <Locks<T, I>>::insert(who, locks);"},
{"lineNum":" 1222","line":"    }"},
{"lineNum":" 1223","line":"}"},
{"lineNum":" 1224","line":""},
{"lineNum":" 1225","line":"/// Require the transactor pay for themselves and maybe include a tip to gain additional priority"},
{"lineNum":" 1226","line":"/// in the queue."},
{"lineNum":" 1227","line":"#[derive(Encode, Decode, Clone, Eq, PartialEq)]"},
{"lineNum":" 1228","line":"pub struct TakeFees<T: Trait<I>, I: Instance = DefaultInstance>(#[codec(compact)] T::Balance);"},
{"lineNum":" 1229","line":""},
{"lineNum":" 1230","line":"impl<T: Trait<I>, I: Instance> TakeFees<T, I> {"},
{"lineNum":" 1231","line":"    /// utility constructor. Used only in client/factory code."},
{"lineNum":" 1232","line":"    pub fn from(fee: T::Balance) -> Self {"},
{"lineNum":" 1233","line":"        Self(fee)"},
{"lineNum":" 1234","line":"    }"},
{"lineNum":" 1235","line":""},
{"lineNum":" 1236","line":"    /// Compute the final fee value for a particular transaction."},
{"lineNum":" 1237","line":"    ///"},
{"lineNum":" 1238","line":"    /// The final fee is composed of:"},
{"lineNum":" 1239","line":"    ///   - _length-fee_: This is the amount paid merely to pay for size of the transaction."},
{"lineNum":" 1240","line":"    ///   - _weight-fee_: This amount is computed based on the weight of the transaction. Unlike"},
{"lineNum":" 1241","line":"    ///      size-fee, this is not input dependent and reflects the _complexity_ of the execution"},
{"lineNum":" 1242","line":"    ///      and the time it consumes."},
{"lineNum":" 1243","line":"    ///   - (optional) _tip_: if included in the transaction, it will be added on top. Only signed"},
{"lineNum":" 1244","line":"    ///      transactions can have a tip."},
{"lineNum":" 1245","line":"    fn compute_fee(len: usize, info: DispatchInfo, tip: T::Balance) -> T::Balance {"},
{"lineNum":" 1246","line":"        let len_fee = if info.pay_length_fee() {"},
{"lineNum":" 1247","line":"            let len = T::Balance::from(len as u32);"},
{"lineNum":" 1248","line":"            let base = T::TransactionBaseFee::get();"},
{"lineNum":" 1249","line":"            let per_byte = T::TransactionByteFee::get();"},
{"lineNum":" 1250","line":"            base.saturating_add(per_byte.saturating_mul(len))"},
{"lineNum":" 1251","line":"        } else {"},
{"lineNum":" 1252","line":"            Zero::zero()"},
{"lineNum":" 1253","line":"        };"},
{"lineNum":" 1254","line":""},
{"lineNum":" 1255","line":"        let weight_fee = {"},
{"lineNum":" 1256","line":"            // cap the weight to the maximum defined in runtime, otherwise it will be the `Bounded`"},
{"lineNum":" 1257","line":"            // maximum of its data type, which is not desired."},
{"lineNum":" 1258","line":"            let capped_weight = info"},
{"lineNum":" 1259","line":"                .weight"},
{"lineNum":" 1260","line":"                .min(<T as system::Trait>::MaximumBlockWeight::get());"},
{"lineNum":" 1261","line":"            let weight_update = <system::Module<T>>::next_weight_multiplier();"},
{"lineNum":" 1262","line":"            let adjusted_weight = weight_update.apply_to(capped_weight);"},
{"lineNum":" 1263","line":"            T::WeightToFee::convert(adjusted_weight)"},
{"lineNum":" 1264","line":"        };"},
{"lineNum":" 1265","line":""},
{"lineNum":" 1266","line":"        len_fee.saturating_add(weight_fee).saturating_add(tip)"},
{"lineNum":" 1267","line":"    }"},
{"lineNum":" 1268","line":"}"},
{"lineNum":" 1269","line":""},
{"lineNum":" 1270","line":"#[cfg(feature = \"std\")]"},
{"lineNum":" 1271","line":"impl<T: Trait<I>, I: Instance> rstd::fmt::Debug for TakeFees<T, I> {"},
{"lineNum":" 1272","line":"    fn fmt(&self, f: &mut rstd::fmt::Formatter) -> rstd::fmt::Result {"},
{"lineNum":" 1273","line":"        self.0.fmt(f)"},
{"lineNum":" 1274","line":"    }"},
{"lineNum":" 1275","line":"}"},
{"lineNum":" 1276","line":""},
{"lineNum":" 1277","line":"impl<T: Trait<I>, I: Instance + Clone + Eq> SignedExtension for TakeFees<T, I> {"},
{"lineNum":" 1278","line":"    type AccountId = T::AccountId;"},
{"lineNum":" 1279","line":"    type Call = T::Call;"},
{"lineNum":" 1280","line":"    type AdditionalSigned = ();"},
{"lineNum":" 1281","line":"    type Pre = ();"},
{"lineNum":" 1282","line":"    fn additional_signed(&self) -> rstd::result::Result<(), TransactionValidityError> {"},
{"lineNum":" 1283","line":"        Ok(())"},
{"lineNum":" 1284","line":"    }"},
{"lineNum":" 1285","line":""},
{"lineNum":" 1286","line":"    fn validate("},
{"lineNum":" 1287","line":"        &self,"},
{"lineNum":" 1288","line":"        who: &Self::AccountId,"},
{"lineNum":" 1289","line":"        _call: &Self::Call,"},
{"lineNum":" 1290","line":"        info: DispatchInfo,"},
{"lineNum":" 1291","line":"        len: usize,"},
{"lineNum":" 1292","line":"    ) -> TransactionValidity {"},
{"lineNum":" 1293","line":"        // pay any fees."},
{"lineNum":" 1294","line":"        let fee = Self::compute_fee(len, info, self.0);"},
{"lineNum":" 1295","line":""},
{"lineNum":" 1296","line":"        let encoded_transactor = match Key::try_from(who.encode()) {"},
{"lineNum":" 1297","line":"            Ok(key) => key,"},
{"lineNum":" 1298","line":"            Err(_) => return InvalidTransaction::BadProof.into(),"},
{"lineNum":" 1299","line":"        };"},
{"lineNum":" 1300","line":""},
{"lineNum":" 1301","line":"        if <T::Identity>::signing_key_charge_did(&encoded_transactor) {"},
{"lineNum":" 1302","line":"            sr_primitives::print(\"Charging fee to identity\");"},
{"lineNum":" 1303","line":"            if !<T::Identity>::charge_poly(&encoded_transactor, fee) {"},
{"lineNum":" 1304","line":"                return InvalidTransaction::Payment.into();"},
{"lineNum":" 1305","line":"            }"},
{"lineNum":" 1306","line":"        } else {"},
{"lineNum":" 1307","line":"            let imbalance = match <Module<T, I>>::withdraw("},
{"lineNum":" 1308","line":"                who,"},
{"lineNum":" 1309","line":"                fee,"},
{"lineNum":" 1310","line":"                WithdrawReason::TransactionPayment,"},
{"lineNum":" 1311","line":"                ExistenceRequirement::KeepAlive,"},
{"lineNum":" 1312","line":"            ) {"},
{"lineNum":" 1313","line":"                Ok(imbalance) => imbalance,"},
{"lineNum":" 1314","line":"                Err(_) => return InvalidTransaction::Payment.into(),"},
{"lineNum":" 1315","line":"            };"},
{"lineNum":" 1316","line":"            T::TransactionPayment::on_unbalanced(imbalance);"},
{"lineNum":" 1317","line":"        }"},
{"lineNum":" 1318","line":""},
{"lineNum":" 1319","line":"        let mut r = ValidTransaction::default();"},
{"lineNum":" 1320","line":"        // NOTE: we probably want to maximize the _fee (of any type) per weight unit_ here, which"},
{"lineNum":" 1321","line":"        // will be a bit more than setting the priority to tip. For now, this is enough."},
{"lineNum":" 1322","line":"        r.priority = fee.saturated_into::<TransactionPriority>();"},
{"lineNum":" 1323","line":"        Ok(r)"},
{"lineNum":" 1324","line":"    }"},
{"lineNum":" 1325","line":"}"},
{"lineNum":" 1326","line":""},
{"lineNum":" 1327","line":"impl<T: Trait<I>, I: Instance> IsDeadAccount<T::AccountId> for Module<T, I>"},
{"lineNum":" 1328","line":"where"},
{"lineNum":" 1329","line":"    T::Balance: MaybeSerializeDebug,"},
{"lineNum":" 1330","line":"{"},
{"lineNum":" 1331","line":"    fn is_dead_account(who: &T::AccountId) -> bool {"},
{"lineNum":" 1332","line":"        Self::total_balance(who).is_zero()"},
{"lineNum":" 1333","line":"    }"},
{"lineNum":" 1334","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "polymesh_runtime-406703dd9310fa0e", "date" : "2019-11-06 13:35:33", "instrumented" : 150, "covered" : 54,};
var merged_data = [];
