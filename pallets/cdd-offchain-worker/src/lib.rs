// To make sure we are on the no_std when compiling to wasm
#![cfg_attr(not(feature = "std"), no_std)]

use frame_support::{
    debug, decl_error, decl_event, decl_module, decl_storage, dispatch::DispatchResult, traits::Get,
};
use frame_system::{self as system, ensure_signed, offchain};
use sp_core::crypto::KeyTypeId;
use sp_runtime::{offchain::storage::StorageValueRef, traits::SaturatedConversion};

#[cfg(test)]
mod mock;
#[cfg(test)]
mod tests;

/// Defines application identifier for crypto keys of this module.
///
/// Every module that deals with signatures needs to declare its unique identifier for
/// its crypto keys.
/// When offchain worker is signing transactions it's going to request keys of type
/// `KeyTypeId` from the keystore and use the ones it finds to sign the transaction.
/// The keys can be inserted manually via RPC (see `author_insertKey`).
pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b"cddw");

/// Based on the above `KeyTypeId` we need to generate a pallet-specific crypto type wrappers.
/// We can use from supported crypto kinds (`sr25519`, `ed25519` and `ecdsa`) and augment
/// the types with this pallet-specific identifier.
pub mod crypto {
    pub use super::KEY_TYPE;
    use sp_runtime::app_crypto::{app_crypto, sr25519};
    app_crypto!(sr25519, KEY_TYPE);
}

pub trait Trait: frame_system::Trait /*pallet_staking::Trait*/ {
    /// The overarching event type.
    type Event: From<Event<Self>> + Into<<Self as system::Trait>::Event>;
    /// The overarching dispatch call type
    type Call: From<Call<Self>>;
    /// No. of blocks delayed to execute the offchain worker
    type CoolingInterval: Get<Self::BlockNumber>;
    /// Buffer given to check the validity of the cdd claim. It is in block numbers.
    type BufferInterval: Get<Self::BlockNumber>;
    /// The type to sign and submit transactions.
    type SubmitSignedTransaction: offchain::SubmitSignedTransaction<Self, <Self as Trait>::Call>;
}

decl_storage! {
    trait Store for Module<T: Trait> as CddOffchainWorker {
        // List of nominators
        // TODO: Used for mocking only. Will be removed once substrate get updated to recent master
        Nominators get(fn nominators): linked_map hasher(blake2_256) T::AccountId => bool;
    }
    add_extra_genesis {
        config(stashIds): Vec<T::AccountId>;
        build(|config: &GenesisConfig<T>| {
            for &(ref stash) in &config.stashIds {
                <Module<T>>::add_nominator(
                    // TODO: change origin to committee
                    frame_system::RawOrigin::Root.into(),
                    stash.clone()
                ).ok();
            }
        });
    }
}

decl_event! {
    /// Events generated by the module.
    pub enum Event<T>
        where
        BlockNumber = <T as frame_system::Trait>::BlockNumber,
        AccountId = <T as frame_system::Trait>::AccountId,
    {
        /// Event generated when nominators get removed from the `Staking` storage
        InvalidateNominators(BlockNumber, Vec<AccountId>),
    }
}

decl_module! {
    pub struct Module<T: Trait> for enum Call where origin: T::Origin {
        type Error = Error<T>;

        /// initialize the default event for this module
        fn deposit_event() = default;

        // TODO: Only used for mock -- Need to removed after upgrade to latest substrate
        fn add_nominator(_origin, nominators: T::AccountId) -> DispatchResult {
            <Nominators<T>>::insert(nominators, true);
            Ok(())
        }

        // TODO: Only used for mock -- Need to removed after upgrade to latest substrate
        fn remove_nominator(origin, nominators: Vec<T::AccountId>) -> DispatchResult {
            let caller = ensure_signed(origin)?;
            for nominator in nominators.iter() {
                <Nominators<T>>::insert(nominator, false);
            }
            Ok(())
        }

        fn offchain_worker(block: T::BlockNumber) {
            // Print the debug statement to know that offchain worker initiated
            debug::native::info!("Hello World from offchain workers!");
            if Self::is_signed_transaction_allowed(block) {
                debug::native::info!("If condition get satisfied!");

                // Fetch all the nominators whose cdd claim get expired or expiry remaining time is less
                // than the `BufferInterval`. List of the Vec<Stash> get retrieved from the staking module
                // TODO: Need to un-comment this when pallets get updated to the latest master (Substrate)
                // let invalid_nominators = <pallet_staking::Module<T>>::fetch_invalid_cdd_nominators((T::BufferInterval::get()).saturated_into::<u64>());
                // TODO: Only used for mock -- Need to removed after upgrade to latest substrate
                let invalid_nominators = Self::fetch_invalid_nominators();

                // Avoid calling signed transaction when invalid nominators length
                // is 0.
                if invalid_nominators.len() > 0 {
                    Self::signed_invalidate_nominators(invalid_nominators);
                }
            }
        }
    }
}

decl_error! {
    pub enum Error for Module<T: Trait> {
        NoLocalAccountAvailable,
    }
}

impl<T: Trait> Module<T> {
    fn signed_invalidate_nominators(
        invalid_nominators: Vec<T::AccountId>,
    ) -> Result<(), &'static str> {
        use frame_system::offchain::SubmitSignedTransaction;
        // First we validate whether any accounts is present in the local storage or not.
        if !T::SubmitSignedTransaction::can_sign() && sp_io::offchain::is_validator() {
            return Err(Error::<T>::NoLocalAccountAvailable.into());
        }
        // Retrieve value of invalidate nominators get passed to the `validate_kyc_expiry_nominators`
        // i.e a public dispatchable in the staking pallet. It will be used to remove all the
        // nominators whom cdd claim got expired.
        // Here we specify the function to be called back on-chain in next block import.
        // TODO: Need to un-comment this when pallets get updated to the latest master (Substrate)
        // let call = pallet_staking::Call<T>::validate_kyc_expiry_nominators(invalid_nominators.clone());
        let call = Call::remove_nominator(invalid_nominators.clone());

        // Using `SubmitTransaction` associated type we create and submit a transaction
        // representing the call, we've just created.
        // Submit signed will return a vector of results for all accounts that were found in the
        // local keystore with expected `KEY_TYPE`.
        let _ = T::SubmitSignedTransaction::submit_signed(call);
        Self::deposit_event(RawEvent::InvalidateNominators(
            <frame_system::Module<T>>::block_number(),
            invalid_nominators,
        ));
        Ok(())
    }

    fn is_signed_transaction_allowed(block_number: T::BlockNumber) -> bool {
        let val = StorageValueRef::persistent(b"cdd_ocw::last_block_checked");

        let res = val.mutate(|last_block_checked: Option<Option<T::BlockNumber>>| {
            match last_block_checked {
                // If we already have a value in storage and the block number is recent enough
                // we avoid sending another transaction at this time.
                Some(Some(block)) if block + T::CoolingInterval::get() < block => Err(()),
                // In every other case we attempt to acquire the lock and send a transaction.
                _ => Ok(block_number),
            }
        });

        //checked whether the `res` value is set to block_number or not
        match res {
            Ok(Ok(block_number)) => true,
            Err(()) => false,
            Ok(Err(_)) => false,
        }
    }

    // TODO: Only used for mock -- Need to removed after upgrade to latest substrate
    /// Returns the mock invalid nominators list
    fn fetch_invalid_nominators() -> Vec<T::AccountId> {
        let invalidate_nominators = <Nominators<T>>::enumerate()
            .into_iter()
            .filter_map(|(stash, status)| {
                if status {
                    return Some(stash);
                } else {
                    None
                }
            })
            .collect::<Vec<T::AccountId>>();
        return invalidate_nominators;
    }
}
